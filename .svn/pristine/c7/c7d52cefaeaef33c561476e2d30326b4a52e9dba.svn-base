/*===================================================================*/
/*                                                                   */
/*  K6502.cpp : 6502 Emulator                                        */
/*                                                                   */
/*  2000/5/10   InfoNES Project ( based on pNesX )                   */
/*                                                                   */
/*===================================================================*/

/*-------------------------------------------------------------------*/
/*  Include files                                                    */
/*-------------------------------------------------------------------*/

#include "K6502.h"
#include "InfoNES_System.h"
/*-------------------------------------------------------------------*/
/*  Global valiables                                                 */
/*-------------------------------------------------------------------*/

// 6502 Register
WORD PC;
BYTE SP;
BYTE F;
BYTE A;
BYTE X;
BYTE Y;

// The state of the IRQ pin
BYTE IRQ_State;

// Wiring of the IRQ pin
BYTE IRQ_Wiring;

// The state of the NMI pin
BYTE NMI_State;

// Wiring of the NMI pin
BYTE NMI_Wiring;

// The number of the clocks that it passed
WORD g_wPassedClocks;

// A table for the test
BYTE g_byTestTable[ 256 ];

// Value and Flag Data
struct value_table_tag
{
  BYTE byValue;
  BYTE byFlag;
};

// A table for ASL
struct value_table_tag g_ASLTable[ 256 ];

// A table for LSR
struct value_table_tag g_LSRTable[ 256 ];

// A table for ROL
struct value_table_tag g_ROLTable[ 2 ][ 256 ];

// A table for ROR
struct value_table_tag g_RORTable[ 2 ][ 256 ];

//typedef struct _funcById0_0
//{
//	WORD id;
//	void  (*func)(void);
//}funcById0_0;
//static void func0_0( void)
//{
//}
///*-------------------------------------------------------------------*/
/*  Operation Macros                                                 */
/*-------------------------------------------------------------------*/
#define FAST_IMPROVE	1
// Clock Op.
#define CLK(a)   g_wPassedClocks += (a);

// Addressing Op.
// Address
// (Indirect,X)
//#if FAST_IMPROVE == 0
//#define AA_IX    K6502_ReadZpW( K6502_Read( PC++ ) + X )
//
//
//
//
//// (Indirect),Y
//#define AA_IY    K6502_ReadZpW( K6502_Read( PC++ ) ) + Y
//
//
//// Zero Page
//#define AA_ZP    K6502_Read( PC++ )
//
//// Zero Page,X
//#define AA_ZPX   (BYTE)( K6502_Read( PC++ ) + X )
//
//
//// Zero Page,Y
//#define AA_ZPY   (BYTE)( K6502_Read( PC++ ) + Y )
//
//// Absolute
//#define AA_ABS   ( K6502_Read( PC++ ) | (WORD)K6502_Read( PC++ ) << 8 )
//
//
//// Absolute2 ( PC-- )
//#define AA_ABS2  ( K6502_Read( PC++ ) | (WORD)K6502_Read( PC ) << 8 )
//
//
//// Absolute,X
//#define AA_ABSX  AA_ABS + X
//// Absolute,Y
//#define AA_ABSY  AA_ABS + Y
//
//// Data
//// (Indirect,X)
//#define A_IX    K6502_Read( AA_IX )
//// (Indirect),Y
//#define A_IY    K6502_ReadIY()
//// Zero Page
//#define A_ZP    K6502_ReadZp( AA_ZP )
//// Zero Page,X
//#define A_ZPX   K6502_ReadZp( AA_ZPX )
//// Zero Page,Y
//#define A_ZPY   K6502_ReadZp( AA_ZPY )
//// Absolute
//#define A_ABS   K6502_Read( AA_ABS )
//// Absolute,X
//#define A_ABSX  K6502_ReadAbsX()
//// Absolute,Y
//#define A_ABSY  K6502_ReadAbsY()
//// Immediate
//#define A_IMM   K6502_Read( PC++ )
//
//
//// Flag Op.
//#define SETF(a)  F |= (a)
//#define RSTF(a)  F &= ~(a)
//#define TEST(a)  RSTF( FLAG_N | FLAG_Z ); SETF( g_byTestTable[ a ] )
//
//// Load & Store Op.
//#define STA(a)    K6502_Write( (a), A );
//#define STX(a)    K6502_Write( (a), X );
//#define STY(a)    K6502_Write( (a), Y );
//#define LDA(a)    A = (a); TEST( A );
//#define LDX(a)    X = (a); TEST( X );
//#define LDY(a)    Y = (a); TEST( Y );
//
//// Stack Op.
//#define PUSH(a)   K6502_Write( BASE_STACK + SP--, (a) )
//#define PUSHW(a)  PUSH( (a) >> 8 ); PUSH( (a) & 0xff )
//#define POP(a)    a = K6502_Read( BASE_STACK + ++SP )
//#define POPW(a)   POP(a);  a |= ( K6502_Read( BASE_STACK + ++SP ) << 8 )
//
//// Logical Op.
//#define ORA(a)  A |= (a); TEST( A )
//#define AND(a)  A &= (a); TEST( A )
//#define EOR(a)  A ^= (a); TEST( A )
//#define BIT(a)  BYTE byD0;byD0 = (a); RSTF( FLAG_N | FLAG_V | FLAG_Z ); SETF( ( byD0 & ( FLAG_N | FLAG_V ) ) | ( ( byD0 & A ) ? 0 : FLAG_Z ) );
//#define CMP(a)  WORD wD0;wD0 = (WORD)A - (a); RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
//#define CPX(a)  WORD wD0;wD0 = (WORD)X - (a); RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
//#define CPY(a)  WORD wD0;wD0 = (WORD)Y - (a); RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
//  
//// Math Op. (A D flag isn't being supported.)
//#define ADC(a)  BYTE byD0;WORD wD0;BYTE byD1; \
//		byD0 = (a); \
//                wD0 = A + byD0 + ( F & FLAG_C ); \
//                byD1 = (BYTE)wD0; \
//                RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C ); \
//                SETF( g_byTestTable[ byD1 ] | ( ( ~( A ^ byD0 ) & ( A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 > 0xff ) ); \
//                A = byD1;
//
//#define SBC(a)  BYTE byD0;WORD wD0;BYTE byD1; \
//		byD0 = (a); \
//                wD0 = A - byD0 - ( ~F & FLAG_C ); \
//                byD1 = (BYTE)wD0; \
//                RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C ); \
//                SETF( g_byTestTable[ byD1 ] | ( ( ( A ^ byD0 ) & ( A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 < 0x100 ) ); \
//                A = byD1;
//
//#define DEC(a)  WORD wA0; BYTE byD0;\
//	wA0 = a; byD0 = K6502_Read( wA0 ); --byD0; K6502_Write( wA0, byD0 ); TEST( byD0 )
//#define INC(a)  WORD wA0; BYTE byD0;\
//	wA0 = a; byD0 = K6502_Read( wA0 ); ++byD0; K6502_Write( wA0, byD0 ); TEST( byD0 )
//
//// Shift Op.
//#define ASLA    RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_ASLTable[ A ].byFlag ); A = g_ASLTable[ A ].byValue 
//#define ASL(a)  WORD wA0; BYTE byD0;RSTF( FLAG_N | FLAG_Z | FLAG_C ); wA0 = a; byD0 = K6502_Read( wA0 ); SETF( g_ASLTable[ byD0 ].byFlag ); K6502_Write( wA0, g_ASLTable[ byD0 ].byValue )
//#define LSRA    RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_LSRTable[ A ].byFlag ); A = g_LSRTable[ A ].byValue 
//#define LSR(a)  WORD wA0; BYTE byD0;RSTF( FLAG_N | FLAG_Z | FLAG_C ); wA0 = a; byD0 = K6502_Read( wA0 ); SETF( g_LSRTable[ byD0 ].byFlag ); K6502_Write( wA0, g_LSRTable[ byD0 ].byValue ) 
//#define ROLA    BYTE byD0;byD0 = F & FLAG_C; RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_ROLTable[ byD0 ][ A ].byFlag ); A = g_ROLTable[ byD0 ][ A ].byValue 
//#define ROL(a)  WORD wA0; BYTE byD0;BYTE byD1;byD1 = F & FLAG_C; RSTF( FLAG_N | FLAG_Z | FLAG_C ); wA0 = a; byD0 = K6502_Read( wA0 ); SETF( g_ROLTable[ byD1 ][ byD0 ].byFlag ); K6502_Write( wA0, g_ROLTable[ byD1 ][ byD0 ].byValue )
//#define RORA    BYTE byD0;byD0 = F & FLAG_C; RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_RORTable[ byD0 ][ A ].byFlag ); A = g_RORTable[ byD0 ][ A ].byValue 
//#define ROR(a)  WORD wA0; BYTE byD0;BYTE byD1;byD1 = F & FLAG_C; RSTF( FLAG_N | FLAG_Z | FLAG_C ); wA0 = a; byD0 = K6502_Read( wA0 ); SETF( g_RORTable[ byD1 ][ byD0 ].byFlag ); K6502_Write( wA0, g_RORTable[ byD1 ][ byD0 ].byValue )
//
//// Jump Op.
//#define JSR     WORD wA0;wA0 = AA_ABS2; PUSHW( PC ); PC = wA0; 
//#if 0
//#define BRA(a)  if ( a ) { wA0 = PC; PC += (char)K6502_Read( PC ); CLK( 3 + ( ( wA0 & 0x0100 ) != ( PC & 0x0100 ) ) ); ++PC; } else { ++PC; CLK( 2 ); }
//#else
//#define BRA(a) WORD wA0; BYTE byD0;\
//{ \
//  if ( a ) \
//  { \
//    wA0 = PC; \
//	byD0 = K6502_Read( PC ); \
//	PC += ( ( byD0 & 0x80 ) ? ( 0xFF00 | (WORD)byD0 ) : (WORD)byD0 ); \
//	CLK( 3 + ( ( wA0 & 0x0100 ) != ( PC & 0x0100 ) ) ); \
//    ++PC; \
//  } else { \
//	++PC; \
//	CLK( 2 ); \
//  } \
//}
//#endif
//#define JMP(a)  PC = a;
//#else
//#define AA_IX    K6502_ReadZpW( K6502_Read( PC++ ) + X )

//#define AA_IX    K6502_ReadZpW( ROM[(PC++)&PC_MASK] + X )
#define AA_IX    K6502_ReadZpW( (PC<0x2000)?(RAM[PC++ ]):(ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff]) + X )


// (Indirect),Y
//#define AA_IY    K6502_ReadZpW( K6502_Read( PC++ ) ) + Y
//#define AA_IY    K6502_ReadZpW( ROM[(PC++)&PC_MASK]) + Y 
#define AA_IY    K6502_ReadZpW( (PC<0x2000)?(RAM[PC++]):(ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff])) + Y 

// Zero Page
//#define AA_ZP    K6502_Read( PC++ )
//#define AA_ZP	 ROM[(PC++)&PC_MASK]
#define AA_ZP	 ((PC<0x2000)?(RAM[PC++]):(ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff]))
// Zero Page,X
//#define AA_ZPX   (BYTE)( K6502_Read( PC++ ) + X )
//#define AA_ZPX   (BYTE)( ROM[(PC++)&PC_MASK] + X )
#define AA_ZPX   (BYTE)( (PC<0x2000)?(RAM[PC++]):(ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff]) + X )

// Zero Page,Y
//#define AA_ZPY   (BYTE)( K6502_Read( PC++ ) + Y )
//#define AA_ZPY   (BYTE)( ROM[(PC++)&PC_MASK]+ Y )
#define AA_ZPY   (BYTE)( (PC<0x2000)?(RAM[PC++]):(ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff]) + Y )
// Absolute
//#define AA_ABS   ( K6502_Read( PC++ ) | (WORD)K6502_Read( PC++ ) << 8 )
//#define AA_ABS   ( ROM[(PC++)&PC_MASK] | ((WORD)ROM[(PC++)&PC_MASK] << 8) )
//#define AA_ABS   ( ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff] | ((WORD)ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff] << 8) )
#define AA_ABS   (PC<0x2000)?(RAM[PC++]|(RAM[PC++]<<8)):( ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff] | ((WORD)ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff] << 8) )
// Absolute2 ( PC-- )
//#define AA_ABS2  ( K6502_Read( PC++ ) | (WORD)K6502_Read( PC ) << 8 )
//#define AA_ABS2  ( ROM[(PC++)&PC_MASK]  | ((WORD)ROM[(PC)&PC_MASK]  << 8) )
//#define AA_ABS2  ( ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff]  | ((WORD)ROMBANK[(PC>>13)&0x3][(PC)&0x1fff]  << 8) )
#define AA_ABS2   (PC<0x2000)?(RAM[PC++]|(RAM[PC]<<8)):( ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff] | ((WORD)ROMBANK[(PC>>13)&0x3][(PC)&0x1fff] << 8) )
// Absolute,X
#define AA_ABSX  AA_ABS + X
// Absolute,Y
#define AA_ABSY  AA_ABS + Y

// Data
// (Indirect,X)
#define A_IX    K6502_Read( AA_IX )
// (Indirect),Y
#define A_IY    K6502_ReadIY()
// Zero Page
#define A_ZP    K6502_ReadZp( AA_ZP )
// Zero Page,X
#define A_ZPX   K6502_ReadZp( AA_ZPX )
// Zero Page,Y
#define A_ZPY   K6502_ReadZp( AA_ZPY )
// Absolute
#define A_ABS   K6502_Read( AA_ABS )
// Absolute,X
#define A_ABSX  K6502_ReadAbsX()
// Absolute,Y
#define A_ABSY  K6502_ReadAbsY()
// Immediate
//#define A_IMM   K6502_Read( PC++ )
//#define A_IMM	ROM[(PC++)&PC_MASK] 
//#define A_IMM	ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff] 
#define A_IMM	(PC<0x2000)?(RAM[PC++]):(ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff]) 
// Flag Op.
#define SETF(a)  F |= (a)
#define RSTF(a)  F &= ~(a)
#define TEST(a)  RSTF( FLAG_N | FLAG_Z ); SETF( g_byTestTable[ a ] )

// Load & Store Op.
#define STA(a)    K6502_Write( (a), A );
#define STX(a)    K6502_Write( (a), X );
#define STY(a)    K6502_Write( (a), Y );
#define LDA(a)    A = (a); TEST( A );
#define LDX(a)    X = (a); TEST( X );
#define LDY(a)    Y = (a); TEST( Y );

// Stack Op.
#define PUSH(a)   RAM[BASE_STACK + (SP--)] = a //K6502_Write( BASE_STACK + SP--, (a) )
#define PUSHW(a)  PUSH( (a) >> 8 ); PUSH( (a) & 0xff )
#define POP(a)    a = RAM[BASE_STACK+(++SP)] //a = K6502_Read( BASE_STACK + ++SP )
#define POPW(a)   POP(a);  a |= ((RAM[BASE_STACK+(++SP)])<<8)//a |= ( K6502_Read( BASE_STACK + ++SP ) << 8 )

// Logical Op.
#define ORA(a)  A |= (a); TEST( A )
#define AND(a)  A &= (a); TEST( A )
#define EOR(a)  A ^= (a); TEST( A )
#define BIT(a)  BYTE byD0;byD0 = (a); RSTF( FLAG_N | FLAG_V | FLAG_Z ); SETF( ( byD0 & ( FLAG_N | FLAG_V ) ) | ( ( byD0 & A ) ? 0 : FLAG_Z ) );
#define CMP(a)  WORD wD0;wD0 = (WORD)A - (a); RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
#define CPX(a)  WORD wD0;wD0 = (WORD)X - (a); RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
#define CPY(a)  WORD wD0;wD0 = (WORD)Y - (a); RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_byTestTable[ wD0 & 0xff ] | ( wD0 < 0x100 ? FLAG_C : 0 ) );
  
// Math Op. (A D flag isn't being supported.)
#define ADC(a)  BYTE byD0;WORD wD0;BYTE byD1; \
		byD0 = (a); \
                wD0 = A + byD0 + ( F & FLAG_C ); \
                byD1 = (BYTE)wD0; \
                RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C ); \
                SETF( g_byTestTable[ byD1 ] | ( ( ~( A ^ byD0 ) & ( A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 > 0xff ) ); \
                A = byD1;

#define SBC(a)  BYTE byD0;WORD wD0;BYTE byD1; \
		byD0 = (a); \
                wD0 = A - byD0 - ( ~F & FLAG_C ); \
                byD1 = (BYTE)wD0; \
                RSTF( FLAG_N | FLAG_V | FLAG_Z | FLAG_C ); \
                SETF( g_byTestTable[ byD1 ] | ( ( ( A ^ byD0 ) & ( A ^ byD1 ) & 0x80 ) ? FLAG_V : 0 ) | ( wD0 < 0x100 ) ); \
                A = byD1;

#define DEC(a)  WORD wA0; BYTE byD0;\
	wA0 = a; byD0 = K6502_Read( wA0 ); --byD0; K6502_Write( wA0, byD0 ); TEST( byD0 )
#define INC(a)  WORD wA0; BYTE byD0;\
	wA0 = a; byD0 = K6502_Read( wA0 ); ++byD0; K6502_Write( wA0, byD0 ); TEST( byD0 )

// Shift Op.
#define ASLA    RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_ASLTable[ A ].byFlag ); A = g_ASLTable[ A ].byValue 
#define ASL(a)  WORD wA0; BYTE byD0;RSTF( FLAG_N | FLAG_Z | FLAG_C ); wA0 = a; byD0 = K6502_Read( wA0 ); SETF( g_ASLTable[ byD0 ].byFlag ); K6502_Write( wA0, g_ASLTable[ byD0 ].byValue )
#define LSRA    RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_LSRTable[ A ].byFlag ); A = g_LSRTable[ A ].byValue 
#define LSR(a)  WORD wA0; BYTE byD0;RSTF( FLAG_N | FLAG_Z | FLAG_C ); wA0 = a; byD0 = K6502_Read( wA0 ); SETF( g_LSRTable[ byD0 ].byFlag ); K6502_Write( wA0, g_LSRTable[ byD0 ].byValue ) 
#define ROLA    BYTE byD0;byD0 = F & FLAG_C; RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_ROLTable[ byD0 ][ A ].byFlag ); A = g_ROLTable[ byD0 ][ A ].byValue 
#define ROL(a)  WORD wA0; BYTE byD0;BYTE byD1;byD1 = F & FLAG_C; RSTF( FLAG_N | FLAG_Z | FLAG_C ); wA0 = a; byD0 = K6502_Read( wA0 ); SETF( g_ROLTable[ byD1 ][ byD0 ].byFlag ); K6502_Write( wA0, g_ROLTable[ byD1 ][ byD0 ].byValue )
#define RORA    BYTE byD0;byD0 = F & FLAG_C; RSTF( FLAG_N | FLAG_Z | FLAG_C ); SETF( g_RORTable[ byD0 ][ A ].byFlag ); A = g_RORTable[ byD0 ][ A ].byValue 
#define ROR(a)  WORD wA0; BYTE byD0;BYTE byD1;byD1 = F & FLAG_C; RSTF( FLAG_N | FLAG_Z | FLAG_C ); wA0 = a; byD0 = K6502_Read( wA0 ); SETF( g_RORTable[ byD1 ][ byD0 ].byFlag ); K6502_Write( wA0, g_RORTable[ byD1 ][ byD0 ].byValue )

// Jump Op.
#define JSR     WORD wA0;wA0 = AA_ABS2; PUSHW( PC ); PC = wA0; 
#if 0
#define BRA(a)  if ( a ) { wA0 = PC; PC += (char)K6502_Read( PC ); CLK( 3 + ( ( wA0 & 0x0100 ) != ( PC & 0x0100 ) ) ); ++PC; } else { ++PC; CLK( 2 ); }
#else
#define BRA(a) WORD wA0; BYTE byD0;\
{ \
  if ( a ) \
  { \
    wA0 = PC; \
	byD0 = (PC<0x2000)?(RAM[PC]):(ROMBANK[(PC>>13)&0x3][(PC)&0x1fff]);/*K6502_Read( PC );*/ \
	PC += ( ( byD0 & 0x80 ) ? ( 0xFF00 | (WORD)byD0 ) : (WORD)byD0 ); \
	CLK( 3 + ( ( wA0 & 0x0100 ) != ( PC & 0x0100 ) ) ); \
    ++PC; \
  } else { \
	++PC; \
	CLK( 2 ); \
  } \
}
#endif
#define JMP(a)  PC = a;
//#endif

/*===================================================================*/
/*                                                                   */
/*                K6502_Init() : Initialize K6502                    */
/*                                                                   */
/*===================================================================*/
void K6502_Init()
{
/*
 *  Initialize K6502
 *
 *  You must call this function only once at first.
 */

  BYTE idx;
  BYTE idx2;

  // The establishment of the IRQ pin
  NMI_Wiring = NMI_State = 1;
  IRQ_Wiring = IRQ_State = 1;

  // Make a table for the test
  idx = 0;
  do
  {
    if ( idx == 0 )
      g_byTestTable[ 0 ] = FLAG_Z;
    else
    if ( idx > 127 )
      g_byTestTable[ idx ] = FLAG_N;
    else
      g_byTestTable[ idx ] = 0;

    ++idx;
  } while ( idx != 0 );

  // Make a table ASL
  idx = 0;
  do
  {
    g_ASLTable[ idx ].byValue = idx << 1;
    g_ASLTable[ idx ].byFlag = 0;

    if ( idx > 127 )
      g_ASLTable[ idx ].byFlag = FLAG_C;

    if ( g_ASLTable[ idx ].byValue == 0 )
      g_ASLTable[ idx ].byFlag |= FLAG_Z;
    else
    if ( g_ASLTable[ idx ].byValue & 0x80 )
      g_ASLTable[ idx ].byFlag |= FLAG_N;

    ++idx;
  } while ( idx != 0 );

  // Make a table LSR
  idx = 0;
  do
  {
    g_LSRTable[ idx ].byValue = idx >> 1;
    g_LSRTable[ idx ].byFlag = 0;

    if ( idx & 1 )
      g_LSRTable[ idx ].byFlag = FLAG_C;

    if ( g_LSRTable[ idx ].byValue == 0 )
      g_LSRTable[ idx ].byFlag |= FLAG_Z;

    ++idx;
  } while ( idx != 0 );

  // Make a table ROL
  for ( idx2 = 0; idx2 < 2; ++idx2 )
  {
    idx = 0;
    do
    {
      g_ROLTable[ idx2 ][ idx ].byValue = ( idx << 1 ) | idx2;
      g_ROLTable[ idx2 ][ idx ].byFlag = 0;

      if ( idx > 127 )
        g_ROLTable[ idx2 ][ idx ].byFlag = FLAG_C;

      if ( g_ROLTable[ idx2 ][ idx ].byValue == 0 )
        g_ROLTable[ idx2 ][ idx ].byFlag |= FLAG_Z;
      else
      if ( g_ROLTable[ idx2 ][ idx ].byValue & 0x80 )
        g_ROLTable[ idx2 ][ idx ].byFlag |= FLAG_N;

      ++idx;
    } while ( idx != 0 );
  }

  // Make a table ROR
  for ( idx2 = 0; idx2 < 2; ++idx2 )
  {
    idx = 0;
    do
    {
      g_RORTable[ idx2 ][ idx ].byValue = ( idx >> 1 ) | ( idx2 << 7 );
      g_RORTable[ idx2 ][ idx ].byFlag = 0;

      if ( idx & 1 )
        g_RORTable[ idx2 ][ idx ].byFlag = FLAG_C;

      if ( g_RORTable[ idx2 ][ idx ].byValue == 0 )
        g_RORTable[ idx2 ][ idx ].byFlag |= FLAG_Z;
      else
      if ( g_RORTable[ idx2 ][ idx ].byValue & 0x80 )
        g_RORTable[ idx2 ][ idx ].byFlag |= FLAG_N;

      ++idx;
    } while ( idx != 0 );
  }
}

/*===================================================================*/
/*                                                                   */
/*                K6502_Reset() : Reset a CPU                        */
/*                                                                   */
/*===================================================================*/
void K6502_Reset()
{
/*
 *  Reset a CPU
 *
 */

  // Reset Registers
  PC = K6502_ReadW( VECTOR_RESET );
  SP = 0xFF;
  A = X = Y = 0;
  F = FLAG_Z | FLAG_R | FLAG_I;
  //debg("NES PC:%x\n", PC);
  //debg("NES PC MASK:%x\n",PC_MASK);
  // Set up the state of the Interrupt pin.
  NMI_State = NMI_Wiring;
  IRQ_State = IRQ_Wiring;

  // Reset Passed Clocks
  g_wPassedClocks = 0;
}

/*===================================================================*/
/*                                                                   */
/*    K6502_Set_Int_Wiring() : Set up wiring of the interrupt pin    */
/*                                                                   */
/*===================================================================*/
void K6502_Set_Int_Wiring( BYTE byNMI_Wiring, BYTE byIRQ_Wiring )
{
/*
 * Set up wiring of the interrupt pin
 *
 */

  NMI_Wiring = byNMI_Wiring;
  IRQ_Wiring = byIRQ_Wiring;
}

//static inline void K6502Ins00(void)
//{
//	++PC; PUSHW( PC ); SETF( FLAG_B ); PUSH( F ); SETF( FLAG_I ); RSTF( FLAG_D ); PC = K6502_ReadW( VECTOR_IRQ ); CLK( 7 );
//}
//static inline void K6502Ins01(void)
//{
//	ORA( A_IX ); CLK( 6 );
//}
//static inline void K6502Ins05(void)
//{
//	ORA( A_ZP ); CLK( 3 );
//}
//static inline void K6502Ins06(void)
//{
//	ASL( AA_ZP ); CLK( 5 );
//}
//static inline void K6502Ins08(void)
//{
//	SETF( FLAG_B ); PUSH( F ); CLK( 3 );
//}
//static inline void K6502Ins09(void)
//{
//	ORA( A_IMM ); CLK( 2 );
//}
//static inline void K6502Ins0a(void)
//{
//	ASLA; CLK( 2 );
//}
//static inline void K6502Ins0d(void)
//{
//	 ORA( A_ABS ); CLK( 4 );
//}
//static inline void K6502Ins0e(void)
//{
//	ASL( AA_ABS ); CLK( 6 );
//}
//
//static inline void K6502Ins10(void)
//{
//	BRA( !( F & FLAG_N ) );
//}
//static inline void K6502Ins11(void)
//{
//	ORA( A_IY ); CLK( 5 );
//}
//static inline void K6502Ins15(void)
//{
//	ORA( A_ZPX ); CLK( 4 );
//}
//static inline void K6502Ins16(void)
//{
//	 ASL( AA_ZPX ); CLK( 6 );
//}
//static inline void K6502Ins18(void)
//{
//	RSTF( FLAG_C ); CLK( 2 );
//}
//static inline void K6502Ins19(void)
//{
//	ORA( A_ABSY ); CLK( 4 );
//}
//static inline void K6502Ins1d(void)
//{
//	ORA( A_ABSX ); CLK( 4 );
//}
//static inline void K6502Ins1e(void)
//{
//	ASL( AA_ABSX ); CLK( 7 );
//}
//static inline void K6502Ins20(void)
//{
//	JSR; CLK( 6 );
//}
//static inline void K6502Ins21(void)
//{
//	AND( A_IX ); CLK( 6 );
//}
//static inline void K6502Ins24(void)
//{
//	BIT( A_ZP ); CLK( 3 );
//}
//static inline void K6502Ins25(void)
//{
//	AND( A_ZP ); CLK( 3 );
//}
//static inline void K6502Ins26(void)
//{
//	 ROL( AA_ZP ); CLK( 5 );
//}
//static inline void K6502Ins28(void)
//{
//	POP( F ); SETF( FLAG_R ); CLK( 4 );
//}
//static inline void K6502Ins29(void)
//{
//	AND( A_IMM ); CLK( 2 );
//}
//static inline void K6502Ins2a(void)
//{
//	ROLA; CLK( 2 );
//}
//static inline void K6502Ins2c(void)
//{
//	BIT( A_ABS ); CLK( 4 );
//}
//static inline void K6502Ins2d(void)
//{
//	AND( A_ABS ); CLK( 4 );
//}
//static inline void K6502Ins2e(void)
//{
//	ROL( AA_ABS ); CLK( 6 );
//}
//
//static inline void K6502Ins30(void)
//{
//	BRA( F & FLAG_N );
//}
//static inline void K6502Ins31(void)
//{
//	AND( A_IY ); CLK( 5 );
//}
//static inline void K6502Ins35(void)
//{
//	AND( A_ZPX ); CLK( 4 );
//}
//static inline void K6502Ins36(void)
//{
//	ROL( AA_ZPX ); CLK( 6 );
//}
//static inline void K6502Ins38(void)
//{
//	SETF( FLAG_C ); CLK( 2 );
//}
//static inline void K6502Ins39(void)
//{
//	AND( A_ABSY ); CLK( 4 );
//}
//static inline void K6502Ins3d(void)
//{
//	AND( A_ABSX ); CLK( 4 );
//}
//static inline void K6502Ins3e(void)
//{
//	ROL( AA_ABSX ); CLK( 7 );
//}
//static inline void K6502Ins40(void)
//{
//	POP( F ); SETF( FLAG_R ); POPW( PC ); CLK( 6 );
//}
//static inline void K6502Ins41(void)
//{
//	EOR( A_IX ); CLK( 6 );
//}
//static inline void K6502Ins45(void)
//{
//	EOR( A_ZP ); CLK( 3 );
//}
//static inline void K6502Ins46(void)
//{
//	LSR( AA_ZP ); CLK( 5 );
//}
//static inline void K6502Ins48(void)
//{
//	PUSH( A ); CLK( 3 );
//}
//static inline void K6502Ins49(void)
//{
//	EOR( A_IMM ); CLK( 2 );
//}
//static inline void K6502Ins4a(void)
//{
//	LSRA; CLK( 2 );
//}
//static inline void K6502Ins4c(void)
//{
//	JMP( AA_ABS ); CLK( 3 );
//}
//static inline void K6502Ins4d(void)
//{
//	EOR( A_ABS ); CLK( 4 );
//}
//static inline void K6502Ins4e(void)
//{
//	LSR( AA_ABS ); CLK( 6 );
//}
//static inline void K6502Ins50(void)
//{
//	BRA( !( F & FLAG_V ) );
//}
//static inline void K6502Ins51(void)
//{
//	EOR( A_IY ); CLK( 5 );
//}
//static inline void K6502Ins55(void)
//{
//	EOR( A_ZPX ); CLK( 4 );
//}
//static inline void K6502Ins56(void)
//{
//	LSR( AA_ZPX ); CLK( 6 );
//}
//static inline void K6502Ins58(void)
//{
//	BYTE byD0;
//	byD0 = F;
//        RSTF( FLAG_I ); CLK( 2 );
//        if ( ( byD0 & FLAG_I ) && IRQ_State != IRQ_Wiring )  
//        {
//          IRQ_State = IRQ_Wiring;          
//          CLK( 7 );
//
//          PUSHW( PC );
//          PUSH( F & ~FLAG_B );
//
//          RSTF( FLAG_D );
//          SETF( FLAG_I );
//    
//          PC = K6502_ReadW( VECTOR_IRQ );
//        }
//}
//static inline void K6502Ins59(void)
//{
//	EOR( A_ABSY ); CLK( 4 );
//}
//static inline void K6502Ins5d(void)
//{
//	EOR( A_ABSX ); CLK( 4 );
//}
//static inline void K6502Ins5e(void)
//{
//	LSR( AA_ABSX ); CLK( 7 );
//}
//static inline void K6502Ins60(void)
//{
//	POPW( PC ); ++PC; CLK( 6 );
//}
//static inline void K6502Ins61(void)
//{
//	ADC( A_IX ); CLK( 6 );
//}
//static inline void K6502Ins65(void)
//{
//	ADC( A_ZP ); CLK( 3 );
//}
//static inline void K6502Ins66(void)
//{
//	ROR( AA_ZP ); CLK( 5 );
//}
//static inline void K6502Ins68(void)
//{
//	POP( A ); TEST( A ); CLK( 4 );
//}
//static inline void K6502Ins69(void)
//{
//	ADC( A_IMM ); CLK( 2 );
//}
//static inline void K6502Ins6a(void)
//{
//	RORA; CLK( 2 );
//}
//static inline void K6502Ins6c(void)
//{
//	JMP( K6502_ReadW2( AA_ABS ) ); CLK( 5 );
////	if(PC<0x8000)
////	debg("[%x]",PC);
//}
//static inline void K6502Ins6d(void)
//{
//	 ADC( A_ABS ); CLK( 4 );
//}
//static inline void K6502Ins6e(void)
//{
//	ROR( AA_ABS ); CLK( 6 );
//}
//static inline void K6502Ins70(void)
//{
//	BRA( F & FLAG_V );
//}
//static inline void K6502Ins71(void)
//{
//	ADC( A_IY ); CLK( 5 );
//}
//static inline void K6502Ins75(void)
//{
//	 ADC( A_ZPX ); CLK( 4 );
//}
//static inline void K6502Ins76(void)
//{
//	ROR( AA_ZPX ); CLK( 6 );
//}
//static inline void K6502Ins78(void)
//{
//	SETF( FLAG_I ); CLK( 2 );
//}
//static inline void K6502Ins79(void)
//{
//	ADC( A_ABSY ); CLK( 4 );
//}
//static inline void K6502Ins7d(void)
//{
//	ADC( A_ABSX ); CLK( 4 );
//}
//static inline void K6502Ins7e(void)
//{
//	ROR( AA_ABSX ); CLK( 7 );
//}
//static inline void K6502Ins81(void)
//{
//	STA( AA_IX ); CLK( 6 );
//}
//static inline void K6502Ins84(void)
//{
//	STY( AA_ZP ); CLK( 3 );
//}
//static inline void K6502Ins85(void)
//{
//	 STA( AA_ZP ); CLK( 3 );
//}
//static inline void K6502Ins86(void)
//{
//	STX( AA_ZP ); CLK( 3 );
//}
//static inline void K6502Ins88(void)
//{
//	--Y; TEST( Y ); CLK( 2 );
//}
//static inline void K6502Ins8a(void)
//{
//	A = X; TEST( A ); CLK( 2 );
//}
//static inline void K6502Ins8c(void)
//{
//	STY( AA_ABS ); CLK( 4 );
//}
//static inline void K6502Ins8d(void)
//{
//	STA( AA_ABS ); CLK( 4 );
//}
//static inline void K6502Ins8e(void)
//{
//	STX( AA_ABS ); CLK( 4 );
//}
//static inline void K6502Ins90(void)
//{
//	BRA( !( F & FLAG_C ) );
//}
//static inline void K6502Ins91(void)
//{
//	STA( AA_IY ); CLK( 6 );
//}
//static inline void K6502Ins94(void)
//{
//	STY( AA_ZPX ); CLK( 4 );
//}
//static inline void K6502Ins95(void)
//{
//	STA( AA_ZPX ); CLK( 4 );
//}
//static inline void K6502Ins96(void)
//{
//	 STX( AA_ZPY ); CLK( 4 );
//}
//static inline void K6502Ins98(void)
//{
//	A = Y; TEST( A ); CLK( 2 );
//}
//static inline void K6502Ins99(void)
//{
//	STA( AA_ABSY ); CLK( 5 );
//}
//static inline void K6502Ins9a(void)
//{
//	SP = X; CLK( 2 );
//}
//static inline void K6502Ins9d(void)
//{
//	STA( AA_ABSX ); CLK( 5 );
//}
//static inline void K6502Insa0(void)
//{
//	LDY( A_IMM ); CLK( 2 );
//}
//static inline void K6502Insa1(void)
//{
//	LDA( A_IX ); CLK( 6 );
//}
//static inline void K6502Insa2(void)
//{
//	LDX( A_IMM ); CLK( 2 );
//}
//static inline void K6502Insa4(void)
//{
//	LDY( A_ZP ); CLK( 3 );
//}
//static inline void K6502Insa5(void)
//{
//	LDA( A_ZP ); CLK( 3 );
//}
//static inline void K6502Insa6(void)
//{
//	LDX( A_ZP ); CLK( 3 );
//}
//static inline void K6502Insa8(void)
//{
//	Y = A; TEST( A ); CLK( 2 );
//}
//static inline void K6502Insa9(void)
//{
//	LDA( A_IMM ); CLK( 2 );
//}
//static inline void K6502Insaa(void)
//{
//	X = A; TEST( A ); CLK( 2 );
//}
//static inline void K6502Insac(void)
//{
//	LDY( A_ABS ); CLK( 4 );
//}
//static inline void K6502Insad(void)
//{
//	LDA( A_ABS ); CLK( 4 );
//}
//static inline void K6502Insae(void)
//{
//	LDX( A_ABS ); CLK( 4 );
//}
//static inline void K6502Insb0(void)
//{
//	BRA( F & FLAG_C );
//}
//static inline void K6502Insb1(void)
//{
//	LDA( A_IY ); CLK( 5 );
//}
//static inline void K6502Insb4(void)
//{
//	LDY( A_ZPX ); CLK( 4 );
//}
//static inline void K6502Insb5(void)
//{
//	LDA( A_ZPX ); CLK( 4 );
//}
//static inline void K6502Insb6(void)
//{
//	LDX( A_ZPY ); CLK( 4 );
//}
//static inline void K6502Insb8(void)
//{
//	RSTF( FLAG_V ); CLK( 2 );
//}
//static inline void K6502Insb9(void)
//{
//	LDA( A_ABSY ); CLK( 4 );
//}
//static inline void K6502Insba(void)
//{
//	X = SP; TEST( X ); CLK( 2 );
//}
//static inline void K6502Insbc(void)
//{
//	LDY( A_ABSX ); CLK( 4 );
//}
//static inline void K6502Insbd(void)
//{
//	LDA( A_ABSX ); CLK( 4 );
//}
//static inline void K6502Insbe(void)
//{
//	LDX( A_ABSY ); CLK( 4 );
//}
//static inline void K6502Insc0(void)
//{
//	CPY( A_IMM ); CLK( 2 );
//}
//static inline void K6502Insc1(void)
//{
//	CMP( A_IX ); CLK( 6 );
//}
//static inline void K6502Insc4(void)
//{
//	 CPY( A_ZP ); CLK( 3 );
//}
//static inline void K6502Insc5(void)
//{
//	CMP( A_ZP ); CLK( 3 );
//}
//static inline void K6502Insc6(void)
//{
//	DEC( AA_ZP ); CLK( 5 );
//}
//static inline void K6502Insc8(void)
//{
//	++Y; TEST( Y ); CLK( 2 );
//}
//static inline void K6502Insc9(void)
//{
//	CMP( A_IMM ); CLK( 2 );
//}
//static inline void K6502Insca(void)
//{
//	 --X; TEST( X ); CLK( 2 );
//}
//static inline void K6502Inscc(void)
//{
//	CPY( A_ABS ); CLK( 4 );
//}
//static inline void K6502Inscd(void)
//{
//	CMP( A_ABS ); CLK( 4 );
//}
//static inline void K6502Insce(void)
//{
//	DEC( AA_ABS ); CLK( 6 );
//}
//static inline void K6502Insd0(void)
//{
//	BRA( !( F & FLAG_Z ) );
//}
//static inline void K6502Insd1(void)
//{
//	CMP( A_IY ); CLK( 5 );
//}
//static inline void K6502Insd5(void)
//{
//	CMP( A_ZPX ); CLK( 4 );
//}
//static inline void K6502Insd6(void)
//{
//	DEC( AA_ZPX ); CLK( 6 );
//}
//static inline void K6502Insd8(void)
//{
//	RSTF( FLAG_D ); CLK( 2 );
//}
//static inline void K6502Insd9(void)
//{
//	CMP( A_ABSY ); CLK( 4 );
//}
//static inline void K6502Insdd(void)
//{
//	CMP( A_ABSX ); CLK( 4 );
//}
//static inline void K6502Insde(void)
//{
//	DEC( AA_ABSX ); CLK( 7 );
//}
//static inline void K6502Inse0(void)
//{
//	CPX( A_IMM ); CLK( 2 );
//}
//static inline void K6502Inse1(void)
//{
//	 SBC( A_IX ); CLK( 6 );
//}
//
//static inline void K6502Inse4(void)
//{
//	CPX( A_ZP ); CLK( 3 );
//}
//static inline void K6502Inse5(void)
//{
//	SBC( A_ZP ); CLK( 3 );
//}
//static inline void K6502Inse6(void)
//{
//	INC( AA_ZP ); CLK( 5 );
//}
//static inline void K6502Inse8(void)
//{
//	++X; TEST( X ); CLK( 2 );
//}
//static inline void K6502Inse9(void)
//{
//	SBC( A_IMM ); CLK( 2 );
//}
//static inline void K6502Insea(void)
//{
//	CLK( 2 );
//}
//static inline void K6502Insec(void)
//{
//	CPX( A_ABS ); CLK( 4 );
//}
//static inline void K6502Insed(void)
//{
//	SBC( A_ABS ); CLK( 4 );
//}
//static inline void K6502Insee(void)
//{
//	INC( AA_ABS ); CLK( 6 );
//}
//static inline void K6502Insf0(void)
//{
//	BRA( F & FLAG_Z );
//}
//static inline void K6502Insf1(void)
//{
//	SBC( A_IY ); CLK( 5 );
//}
//static inline void K6502Insf5(void)
//{
//	SBC( A_ZPX ); CLK( 4 );
//}
//static inline void K6502Insf6(void)
//{
//	INC( AA_ZPX ); CLK( 6 );
//}
//static inline void K6502Insf8(void)
//{
//	SETF( FLAG_D ); CLK( 2 );
//}
//static inline void K6502Insf9(void)
//{
//	SBC( A_ABSY ); CLK( 4 );
//}
//static inline void K6502Insfd(void)
//{
//	SBC( A_ABSX ); CLK( 4 );
//}
//static inline void K6502Insfe(void)
//{
//	INC( AA_ABSX ); CLK( 7 );
//}
//
//static inline void K6502Ins_A(void)
//{
//	CLK( 2 );
//}
//static inline void K6502InsCycles2(void)
//{
//	PC++;
//	CLK( 2 );
//}
//static inline void K6502InsCycles3(void)
//{
//	PC++;
//	CLK( 3 );
//}
//static inline void K6502InsCycles4(void)
//{
//	PC++; 
//	CLK( 4 );
//}
//static inline void K6502InsTop(void)
//{
//	PC+=2;
//	CLK( 4 );
//}
//static inline void K6502InsDefault(void)
//{
//	CLK( 2 );
//}
//static funcById0_0 K6502_instruction_func[]=
//{
//	{0x00,K6502Ins00},
//	{0x01,K6502Ins01},
//	{0x02,K6502InsDefault},
//	{0x03,K6502InsDefault},
//	{0x04,K6502InsCycles3},
//	{0x05,K6502Ins05},
//	{0x06,K6502Ins06},
//	{0x07,K6502InsDefault},
//	{0x08,K6502Ins08},
//	{0x09,K6502Ins09},
//	{0x0a,K6502Ins0a},
//	{0x0b,K6502InsDefault},
//	{0x0c,K6502InsTop},
//	{0x0d,K6502Ins0d},
//	{0x0e,K6502Ins0e},
//	{0x0f,K6502InsDefault},
//
//	{0x10,K6502Ins10},
//	{0x11,K6502Ins11},
//	{0x12,K6502InsDefault},
//	{0x13,K6502InsDefault},
//	{0x14,K6502InsCycles4},
//	{0x15,K6502Ins15},
//	{0x16,K6502Ins16},
//	{0x17,K6502InsDefault},
//	{0x18,K6502Ins18},
//	{0x19,K6502Ins19},
//	{0x1a,K6502Ins_A},
//	{0x1b,K6502InsDefault},
//	{0x1c,K6502InsTop},
//	{0x1d,K6502Ins1d},
//	{0x1e,K6502Ins1e},
//	{0x1f,K6502InsDefault},
//
//	{0x20,K6502Ins20},
//	{0x21,K6502Ins21},
//	{0x22,K6502InsDefault},
//	{0x23,K6502InsDefault},
//	{0x24,K6502Ins24},
//	{0x25,K6502Ins25},
//	{0x26,K6502Ins26},
//	{0x27,K6502InsDefault},
//	{0x28,K6502Ins28},
//	{0x29,K6502Ins29},
//	{0x2a,K6502Ins2a},
//	{0x2b,K6502InsDefault},
//	{0x2c,K6502Ins2c},
//	{0x2d,K6502Ins2d},
//	{0x2e,K6502Ins2e},
//	{0x2f,K6502InsDefault},
//
//	{0x30,K6502Ins30},
//	{0x31,K6502Ins31},
//	{0x32,K6502InsDefault},
//	{0x33,K6502InsDefault},
//	{0x34,K6502InsCycles4},
//	{0x35,K6502Ins35},
//	{0x36,K6502Ins36},
//	{0x37,K6502InsDefault},
//	{0x38,K6502Ins38},
//	{0x39,K6502Ins39},
//	{0x3a,K6502Ins_A},
//	{0x3b,K6502InsDefault},
//	{0x3c,K6502InsTop},
//	{0x3d,K6502Ins3d},
//	{0x3e,K6502Ins3e},
//	{0x3f,K6502InsDefault},
//
//	{0x40,K6502Ins40},
//	{0x41,K6502Ins41},
//	{0x42,K6502InsDefault},
//	{0x43,K6502InsDefault},
//	{0x44,K6502InsCycles3},
//	{0x45,K6502Ins45},
//	{0x46,K6502Ins46},
//	{0x47,K6502InsDefault},
//	{0x48,K6502Ins48},
//	{0x49,K6502Ins49},
//	{0x4a,K6502Ins4a},
//	{0x4b,K6502InsDefault},
//	{0x4c,K6502Ins4c},
//	{0x4d,K6502Ins4d},
//	{0x4e,K6502Ins4e},
//	{0x4f,K6502InsDefault},
//
//	{0x50,K6502Ins50},
//	{0x51,K6502Ins51},
//	{0x52,K6502InsDefault},
//	{0x53,K6502InsDefault},
//	{0x54,K6502InsCycles4},
//	{0x55,K6502Ins55},
//	{0x56,K6502Ins56},
//	{0x57,K6502InsDefault},
//	{0x58,K6502Ins58},
//	{0x59,K6502Ins59},
//	{0x5a,K6502Ins_A},
//	{0x5b,K6502InsDefault},
//	{0x5c,K6502InsTop},
//	{0x5d,K6502Ins5d},
//	{0x5e,K6502Ins5e},
//	{0x5f,K6502InsDefault},
//
//	{0x60,K6502Ins60},
//	{0x61,K6502Ins61},
//	{0x62,K6502InsDefault},
//	{0x63,K6502InsDefault},
//	{0x64,K6502InsCycles3},
//	{0x65,K6502Ins65},
//	{0x66,K6502Ins66},
//	{0x67,K6502InsDefault},
//	{0x68,K6502Ins68},
//	{0x69,K6502Ins69},
//	{0x6a,K6502Ins6a},
//	{0x6b,K6502InsDefault},
//	{0x6c,K6502Ins6c},
//	{0x6d,K6502Ins6d},
//	{0x6e,K6502Ins6e},
//	{0x6f,K6502InsDefault},
//
//	{0x70,K6502Ins70},
//	{0x71,K6502Ins71},
//	{0x72,K6502InsDefault},
//	{0x73,K6502InsDefault},
//	{0x74,K6502InsCycles4},
//	{0x75,K6502Ins75},
//	{0x76,K6502Ins76},
//	{0x77,K6502InsDefault},
//	{0x78,K6502Ins78},
//	{0x79,K6502Ins79},
//	{0x7a,K6502Ins_A},
//	{0x7b,K6502InsDefault},
//	{0x7c,K6502InsTop},
//	{0x7d,K6502Ins7d},
//	{0x7e,K6502Ins7e},
//	{0x7f,K6502InsDefault},
//
//	{0x80,K6502InsCycles2},
//	{0x81,K6502Ins81},
//	{0x82,K6502InsCycles2},
//	{0x83,K6502InsDefault},
//	{0x84,K6502Ins84},
//	{0x85,K6502Ins85},
//	{0x86,K6502Ins86},
//	{0x87,K6502InsDefault},
//	{0x88,K6502Ins88},
//	{0x89,K6502InsCycles2},
//	{0x8a,K6502Ins8a},
//	{0x8b,K6502InsDefault},
//	{0x8c,K6502Ins8c},
//	{0x8d,K6502Ins8d},
//	{0x8e,K6502Ins8e},
//	{0x8f,K6502InsDefault},
//
//	{0x90,K6502Ins90},
//	{0x91,K6502Ins91},
//	{0x92,K6502InsDefault},
//	{0x93,K6502InsDefault},
//	{0x94,K6502Ins94},
//	{0x95,K6502Ins95},
//	{0x96,K6502Ins96},
//	{0x97,K6502InsDefault},
//	{0x98,K6502Ins98},
//	{0x99,K6502Ins99},
//	{0x9a,K6502Ins9a},
//	{0x9b,K6502InsDefault},
//	{0x9c,K6502InsDefault},
//	{0x9d,K6502Ins9d},
//	{0x9e,K6502InsDefault},
//	{0x9f,K6502InsDefault},
//
//	{0xa0,K6502Insa0},
//	{0xa1,K6502Insa1},
//	{0xa2,K6502Insa2},
//	{0xa3,K6502InsDefault},
//	{0xa4,K6502Insa4},
//	{0xa5,K6502Insa5},
//	{0xa6,K6502Insa6},
//	{0xa7,K6502InsDefault},
//	{0xa8,K6502Insa8},
//	{0xa9,K6502Insa9},
//	{0xaa,K6502Insaa},
//	{0xab,K6502InsDefault},
//	{0xac,K6502Insac},
//	{0xad,K6502Insad},
//	{0xae,K6502Insae},
//	{0xaf,K6502InsDefault},
//
//	{0xb0,K6502Insb0},
//	{0xb1,K6502Insb1},
//	{0xb2,K6502InsDefault},
//	{0xb3,K6502InsDefault},
//	{0xb4,K6502Insb4},
//	{0xb5,K6502Insb5},
//	{0xb6,K6502Insb6},
//	{0xb7,K6502InsDefault},
//	{0xb8,K6502Insb8},
//	{0xb9,K6502Insb9},
//	{0xba,K6502Insba},
//	{0xbb,K6502InsDefault},
//	{0xbc,K6502Insbc},
//	{0xbd,K6502Insbd},
//	{0xbe,K6502Insbe},
//	{0xbf,K6502InsDefault},
//
//	{0xc0,K6502Insc0},
//	{0xc1,K6502Insc1},
//	{0xc2,K6502InsCycles2},
//	{0xc3,K6502InsDefault},
//	{0xc4,K6502Insc4},
//	{0xc5,K6502Insc5},
//	{0xc6,K6502Insc6},
//	{0xc7,K6502InsDefault},
//	{0xc8,K6502Insc8},
//	{0xc9,K6502Insc9},
//	{0xca,K6502Insca},
//	{0xcb,K6502InsDefault},
//	{0xcc,K6502Inscc},
//	{0xcd,K6502Inscd},
//	{0xce,K6502Insce},
//	{0xcf,K6502InsDefault},
//
//	{0xd0,K6502Insd0},
//	{0xd1,K6502Insd1},
//	{0xd2,K6502InsDefault},
//	{0xd3,K6502InsDefault},
//	{0xd4,K6502InsCycles4},
//	{0xd5,K6502Insd5},
//	{0xd6,K6502Insd6},
//	{0xd7,K6502InsDefault},
//	{0xd8,K6502Insd8},
//	{0xd9,K6502Insd9},
//	{0xda,K6502Ins_A},
//	{0xdb,K6502InsDefault},
//	{0xdc,K6502InsTop},
//	{0xdd,K6502Insdd},
//	{0xde,K6502Insde},
//	{0xdf,K6502InsDefault},
//
//	{0xe0,K6502Inse0},
//	{0xe1,K6502Inse1},
//	{0xe2,K6502InsCycles2},
//	{0xe3,K6502InsDefault},
//	{0xe4,K6502Inse4},
//	{0xe5,K6502Inse5},
//	{0xe6,K6502Inse6},
//	{0xe7,K6502InsDefault},
//	{0xe8,K6502Inse8},
//	{0xe9,K6502Inse9},
//	{0xea,K6502Insea},
//	{0xeb,K6502InsDefault},
//	{0xec,K6502Insec},
//	{0xed,K6502Insed},
//	{0xee,K6502Insee},
//	{0xef,K6502InsDefault},
//
//	{0xf0,K6502Insf0},
//	{0xf1,K6502Insf1},
//	{0xf2,K6502InsDefault},
//	{0xf3,K6502InsDefault},
//	{0xf4,K6502InsCycles4},
//	{0xf5,K6502Insf5},
//	{0xf6,K6502Insf6},
//	{0xf7,K6502InsDefault},
//	{0xf8,K6502Insf8},
//	{0xf9,K6502Insf9},
//	{0xfa,K6502Ins_A},
//	{0xfb,K6502InsDefault},
//	{0xfc,K6502InsTop},
//	{0xfd,K6502Insfd},
//	{0xfe,K6502Insfe},
//	{0xff,K6502InsDefault},
//};
/*===================================================================*/
/*                                                                   */
/*  K6502_Step() :                                                   */
/*          Only the specified number of the clocks execute Op.      */
/*                                                                   */
/*===================================================================*/
__nes_code void K6502_Step( WORD wClocks )
{
/*
 *  Only the specified number of the clocks execute Op.
 *
 *  Parameters
 *    WORD wClocks              (Read)
 *      The number of the clocks
 */

  BYTE byCode;

  
  
  
  

  // Dispose of it if there is an interrupt requirement
  if ( NMI_State != NMI_Wiring )
  {
    // NMI Interrupt
    NMI_State = NMI_Wiring;
    CLK( 7 );

    PUSHW( PC );
    PUSH( F & ~FLAG_B );

    RSTF( FLAG_D );
    SETF( FLAG_I );

    PC = K6502_ReadW( VECTOR_NMI );
  }
  else
  if ( IRQ_State != IRQ_Wiring )
  {
    // IRQ Interrupt
    // Execute IRQ if an I flag isn't being set
    if ( !( F & FLAG_I ) )
    {
      IRQ_State = IRQ_Wiring;
      CLK( 7 );

      PUSHW( PC );
      PUSH( F & ~FLAG_B );

      RSTF( FLAG_D );
      SETF( FLAG_I );
    
      PC = K6502_ReadW( VECTOR_IRQ );
    }
  }
  
 // control = 0;
  // It has a loop until a constant clock passes
  while ( g_wPassedClocks < wClocks )
  {
	
    // Read an instruction
	#if FAST_IMPROVE == 0
	
    byCode =K6502_Read( PC++ );
	//byCode	= ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff];
//	if(PC<0x8000)
//		debg("PC:%x, byCode:%x\n",PC, byCode);
	#else
	//byCode =K6502_Read( PC++ );
	byCode	= (PC<0x2000)?RAM[PC++]:ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff];
//	if((PC>0x2000)&&(PC<0x8000))
//	{
//		debg("PC:%x, byCode:%x\n",PC, byCode);
//	}
	#endif
 //   K6502_instruction_func[byCode].func();
	switch (byCode) {
	case 0x00: {++PC; PUSHW( PC ); SETF( FLAG_B ); PUSH( F ); SETF( FLAG_I ); RSTF( FLAG_D ); PC = K6502_ReadW( VECTOR_IRQ ); CLK( 7 ); break;}
	case 0x01: {ORA( A_IX ); CLK( 6 ); break;}
	case 0x02: {CLK( 2 ); break;}
	case 0x03: {CLK( 2 ); break;}
	case 0x04: {PC++;CLK( 3 ); break;}
	case 0x05: {ORA( A_ZP ); CLK( 3 ); break;}
	case 0x06: {ASL( AA_ZP ); CLK( 5 ); break;}
	case 0x07: {CLK( 2 ); break;}
	case 0x08: {SETF( FLAG_B ); PUSH( F ); CLK( 3 ); break;}
	case 0x09: {ORA( A_IMM ); CLK( 2 ); break;}
	case 0x0a: {ASLA; CLK( 2 ); break;}
	case 0x0b: {CLK( 2 ); break;}
	case 0x0c: {PC+=2;CLK( 4 ); break;}
	case 0x0d: {ORA( A_ABS ); CLK( 4 ); break;}
	case 0x0e: {ASL( AA_ABS ); CLK( 6 ); break;}
	case 0x0f: {CLK( 2 ); break;}
	case 0x10: {BRA( !( F & FLAG_N ) ); break;}
	case 0x11: {ORA( A_IY ); CLK( 5 ); break;}
	case 0x12: {CLK( 2 ); break;}
	case 0x13: {CLK( 2 ); break;}
	case 0x14: {PC++; CLK( 4 ); break;}
	case 0x15: {ORA( A_ZPX ); CLK( 4 ); break;}
	case 0x16: {ASL( AA_ZPX ); CLK( 6 ); break;}
	case 0x17: {CLK( 2 ); break;}
	case 0x18: {RSTF( FLAG_C ); CLK( 2 ); break;}
	case 0x19: {ORA( A_ABSY ); CLK( 4 ); break;}
	case 0x1a: {CLK( 2 ); break;}
	case 0x1b: {CLK( 2 ); break;}
	case 0x1c: {PC+=2; CLK( 4 ); break;}
	case 0x1d: {ORA( A_ABSX ); CLK( 4 ); break;}
	case 0x1e: {ASL( AA_ABSX ); CLK( 7 ); break;}
	case 0x1f: {CLK( 2 ); break;}
	case 0x20: {JSR; CLK( 6 ); break;}
	case 0x21: {AND( A_IX ); CLK( 6 ); break;}
	case 0x22: {CLK( 2 ); break;}
	case 0x23: {CLK( 2 ); break;}
	case 0x24: {BIT( A_ZP ); CLK( 3 ); break;}
	case 0x25: {AND( A_ZP ); CLK( 3 ); break;}
	case 0x26: {ROL( AA_ZP ); CLK( 5 ); break;}
	case 0x27: {CLK( 2 ); break;}
	case 0x28: {POP( F ); SETF( FLAG_R ); CLK( 4 ); break;}
	case 0x29: {AND( A_IMM ); CLK( 2 ); break;}
	case 0x2a: {ROLA; CLK( 2 ); break;}
	case 0x2b: {CLK( 2 ); break;}
	case 0x2c: {BIT( A_ABS ); CLK( 4 ); break;}
	case 0x2d: {AND( A_ABS ); CLK( 4 ); break;}
	case 0x2e: {ROL( AA_ABS ); CLK( 6 ); break;}
	case 0x2f: {CLK( 2 ); break;}
	case 0x30: {BRA( F & FLAG_N ); break;}
	case 0x31: {AND( A_IY ); CLK( 5 ); break;}
	case 0x32: {CLK( 2 ); break;}
	case 0x33: {CLK( 2 ); break;}
	case 0x34: {PC++; CLK( 4 ); break;}
	case 0x35: {AND( A_ZPX ); CLK( 4 ); break;}
	case 0x36: {ROL( AA_ZPX ); CLK( 6 ); break;}
	case 0x37: {CLK( 2 ); break;}
	case 0x38: {SETF( FLAG_C ); CLK( 2 ); break;}
	case 0x39: {AND( A_ABSY ); CLK( 4 ); break;}
	case 0x3a: {CLK( 2 ); break;}
	case 0x3b: {CLK( 2 ); break;}
	case 0x3c: {PC+=2; CLK( 4 ); break;}
	case 0x3d: {AND( A_ABSX ); CLK( 4 ); break;}
	case 0x3e: {ROL( AA_ABSX ); CLK( 7 ); break;}
	case 0x3f: {CLK( 2 ); break;}
	case 0x40: {POP( F ); SETF( FLAG_R ); POPW( PC ); CLK( 6 ); break;}
	case 0x41: {EOR( A_IX ); CLK( 6 ); break;}
	case 0x42: {CLK( 2 ); break;}
	case 0x43: {CLK( 2 ); break;}
	case 0x44: {PC++; CLK( 3 ); break;}
	case 0x45: {EOR( A_ZP ); CLK( 3 ); break;}
	case 0x46: {LSR( AA_ZP ); CLK( 5 ); break;}
	case 0x47: {CLK( 2 ); break;}
	case 0x48: {PUSH( A ); CLK( 3 ); break;}
	case 0x49: {EOR( A_IMM ); CLK( 2 ); break;}
	case 0x4a: {LSRA; CLK( 2 ); break;}
	case 0x4b: {CLK( 2 ); break;}
	case 0x4c: {JMP( AA_ABS ); CLK( 3 ); break;}
	case 0x4d: {EOR( A_ABS ); CLK( 4 ); break;}
	case 0x4e: {LSR( AA_ABS ); CLK( 6 ); break;}
	case 0x4f: {CLK( 2 ); break;}
	case 0x50: {BRA( !( F & FLAG_V ) ); break;}
	case 0x51: {EOR( A_IY ); CLK( 5 ); break;}
	case 0x52: {CLK( 2 ); break;}
	case 0x53: {CLK( 2 ); break;}
	case 0x54: {PC++; CLK( 4 ); break;}
	case 0x55: {EOR( A_ZPX ); CLK( 4 ); break;}
	case 0x56: {LSR( AA_ZPX ); CLK( 6 ); break;}
	case 0x57: {CLK( 2 ); break;}
	case 0x58: 
	{
		BYTE byD0;
		byD0 = F;
        RSTF( FLAG_I ); CLK( 2 );
        if ( ( byD0 & FLAG_I ) && IRQ_State != IRQ_Wiring )  
        {
          IRQ_State = IRQ_Wiring;          
          CLK( 7 );

          PUSHW( PC );
          PUSH( F & ~FLAG_B );

          RSTF( FLAG_D );
          SETF( FLAG_I );
    
          PC = K6502_ReadW( VECTOR_IRQ );
        } break;
		
	}
	case 0x59: {EOR( A_ABSY ); CLK( 4 ); break;}
	case 0x5a: {CLK( 2 ); break;}
	case 0x5b: {CLK( 2 ); break;}
	case 0x5c: {PC+=2; CLK( 4 ); break;}
	case 0x5d: {EOR( A_ABSX ); CLK( 4 ); break;}
	case 0x5e: {LSR( AA_ABSX ); CLK( 7 ); break;}
	case 0x5f: {CLK( 2 ); break;}
	case 0x60: {POPW( PC ); ++PC; CLK( 6 ); break;}
	case 0x61: {ADC( A_IX ); CLK( 6 ); break;}
	case 0x62: {CLK( 2 ); break;}
	case 0x63: {CLK( 2 ); break;}
	case 0x64: {PC++;CLK( 3 ); break;}
	case 0x65: {ADC( A_ZP ); CLK( 3 ); break;}
	case 0x66: {ROR( AA_ZP ); CLK( 5 ); break;}
	case 0x67: {CLK( 2 ); break;}
	case 0x68: {POP( A ); TEST( A ); CLK( 4 ); break;}
	case 0x69: {ADC( A_IMM ); CLK( 2 ); break;}
	case 0x6a: {RORA; CLK( 2 ); break;}
	case 0x6b: {CLK( 2 ); break;}
	case 0x6c: {JMP( K6502_ReadW2( AA_ABS ) ); CLK( 5 ); break;}
	case 0x6d: {ADC( A_ABS ); CLK( 4 ); break;}
	case 0x6e: {ROR( AA_ABS ); CLK( 6 ); break;}
	case 0x6f: {CLK( 2 ); break;}
	case 0x70: {BRA( F & FLAG_V ); break;}
	case 0x71: {ADC( A_IY ); CLK( 5 ); break;}
	case 0x72: {CLK( 2 ); break;}
	case 0x73: {CLK( 2 ); break;}
	case 0x74: {PC++; CLK( 4 ); break;}
	case 0x75: {ADC( A_ZPX ); CLK( 4 ); break;}
	case 0x76: {ROR( AA_ZPX ); CLK( 6 ); break;}
	case 0x77: {CLK( 2 ); break;}
	case 0x78: {SETF( FLAG_I ); CLK( 2 ); break;}
	case 0x79: {ADC( A_ABSY ); CLK( 4 ); break;}
	case 0x7a: {CLK( 2 ); break;}
	case 0x7b: {CLK( 2 ); break;}
	case 0x7c: {PC+=2;CLK( 4 ); break;}
	case 0x7d: {ADC( A_ABSX ); CLK( 4 ); break;}
	case 0x7e: {ROR( AA_ABSX ); CLK( 7 ); break;}
	case 0x7f: {CLK( 2 ); break;}
	case 0x80: {PC++; CLK( 2 ); break;}
	case 0x81: {STA( AA_IX ); CLK( 6 ); break;}
	case 0x82: {PC++;CLK( 2 ); break;}
	case 0x83: {CLK( 2 ); break;}
	case 0x84: {STY( AA_ZP ); CLK( 3 ); break;}
	case 0x85: {STA( AA_ZP ); CLK( 3 ); break;}
	case 0x86: {STX( AA_ZP ); CLK( 3 ); break;}
	case 0x87: {CLK( 2 ); break;}
	case 0x88: {--Y; TEST( Y ); CLK( 2 ); break;}
	case 0x89: {PC++; CLK( 2 ); break;}
	case 0x8a: {A = X; TEST( A ); CLK( 2 ); break;}
	case 0x8b: {CLK( 2 ); break;}
	case 0x8c: {STY( AA_ABS ); CLK( 4 ); break;}
	case 0x8d: {STA( AA_ABS ); CLK( 4 ); break;}
	case 0x8e: {STX( AA_ABS ); CLK( 4 ); break;}
	case 0x8f: {CLK( 2 ); break;}
	case 0x90: {BRA( !( F & FLAG_C ) ); break;}
	case 0x91: {STA( AA_IY ); CLK( 6 ); break;}
	case 0x92: {CLK( 2 ); break;}
	case 0x93: {CLK( 2 ); break;}
	case 0x94: {STY( AA_ZPX ); CLK( 4 ); break;}
	case 0x95: {STA( AA_ZPX ); CLK( 4 ); break;}
	case 0x96: {STX( AA_ZPY ); CLK( 4 ); break;}
	case 0x97: {CLK( 2 ); break;}
	case 0x98: {A = Y; TEST( A ); CLK( 2 ); break;}
	case 0x99: {STA( AA_ABSY ); CLK( 5 ); break;}
	case 0x9a: {SP = X; CLK( 2 ); break;}
	case 0x9b: {CLK( 2 ); break;}
	case 0x9c: {CLK( 2 ); break;}
	case 0x9d: {STA( AA_ABSX ); CLK( 5 ); break;}
	case 0x9e: {CLK( 2 );break;}
	case 0x9f: {CLK( 2 ); break;}
	case 0xa0: {LDY( A_IMM ); CLK( 2 ); break;}
	case 0xa1: {LDA( A_IX ); CLK( 6 ); break;}
	case 0xa2: {LDX( A_IMM ); CLK( 2 ); break;}
	case 0xa3: {CLK( 2 ); break;}
	case 0xa4: {LDY( A_ZP ); CLK( 3 ); break;}
	case 0xa5: {LDA( A_ZP ); CLK( 3 ); break;}
	case 0xa6: {LDX( A_ZP ); CLK( 3 ); break;}
	case 0xa7: {CLK( 2 ); break;}
	case 0xa8: {Y = A; TEST( A ); CLK( 2 ); break;}
	case 0xa9: {LDA( A_IMM ); CLK( 2 ); break;}
	case 0xaa: {X = A; TEST( A ); CLK( 2 ); break;}
	case 0xab: {CLK( 2 ); break;}
	case 0xac: {LDY( A_ABS ); CLK( 4 ); break;}
	case 0xad: {LDA( A_ABS ); CLK( 4 ); break;}
	case 0xae: {LDX( A_ABS ); CLK( 4 ); break;}
	case 0xaf: {CLK( 2 ); break;}
	case 0xb0: {BRA( F & FLAG_C ); break;}
	case 0xb1: {LDA( A_IY ); CLK( 5 ); break;}
	case 0xb2: {CLK( 2 ); break;}
	case 0xb3: {CLK( 2 ); break;}
	case 0xb4: {LDY( A_ZPX ); CLK( 4 ); break;}
	case 0xb5: {LDA( A_ZPX ); CLK( 4 ); break;}
	case 0xb6: {LDX( A_ZPY ); CLK( 4 ); break;}
	case 0xb7: {CLK( 2 ); break;}
	case 0xb8: {RSTF( FLAG_V ); CLK( 2 ); break;}
	case 0xb9: {LDA( A_ABSY ); CLK( 4 ); break;}
	case 0xba: {X = SP; TEST( X ); CLK( 2 ); break;}
	case 0xbb: {CLK( 2 ); break;}
	case 0xbc: {LDY( A_ABSX ); CLK( 4 ); break;}
	case 0xbd: {LDA( A_ABSX ); CLK( 4 ); break;}
	case 0xbe: {LDX( A_ABSY ); CLK( 4 ); break;}
	case 0xbf: {CLK( 2 ); break;}
	case 0xc0: {CPY( A_IMM ); CLK( 2 ); break;}
	case 0xc1: {CMP( A_IX ); CLK( 6 ); break;}
	case 0xc2: {PC++; CLK( 2 ); break;}
	case 0xc3: {CLK( 2 ); break;}
	case 0xc4: {CPY( A_ZP ); CLK( 3 ); break;}
	case 0xc5: {CMP( A_ZP ); CLK( 3 ); break;}
	case 0xc6: {DEC( AA_ZP ); CLK( 5 ); break;}
	case 0xc7: {CLK( 2 ); break;}
	case 0xc8: {++Y; TEST( Y ); CLK( 2 ); break;}
	case 0xc9: {CMP( A_IMM ); CLK( 2 ); break;}
	case 0xca: {--X; TEST( X ); CLK( 2 ); break;}
	case 0xcb: {CLK( 2 ); break;}
	case 0xcc: {CPY( A_ABS ); CLK( 4 ); break;}
	case 0xcd: {CMP( A_ABS ); CLK( 4 ); break;}
	case 0xce: {DEC( AA_ABS ); CLK( 6 ); break;}
	case 0xcf: {CLK( 2 ); break;}
	case 0xd0: {BRA( !( F & FLAG_Z ) ); break;}
	case 0xd1: {CMP( A_IY ); CLK( 5 ); break;}
	case 0xd2: {CLK( 2 ); break;}
	case 0xd3: {CLK( 2 ); break;}
	case 0xd4: {PC++; CLK( 4 ); break;}
	case 0xd5: {CMP( A_ZPX ); CLK( 4 ); break;}
	case 0xd6: {DEC( AA_ZPX ); CLK( 6 ); break;}
	case 0xd7: {CLK( 2 ); break;}
	case 0xd8: {RSTF( FLAG_D ); CLK( 2 ); break;}
	case 0xd9: {CMP( A_ABSY ); CLK( 4 ); break;}
	case 0xda: {CLK( 2 ); break;}
	case 0xdb: {CLK( 2 ); break;}
	case 0xdc: {PC+=2; CLK( 4 ); break;}
	case 0xdd: {CMP( A_ABSX ); CLK( 4 ); break;}
	case 0xde: {DEC( AA_ABSX ); CLK( 7 ); break;}
	case 0xdf: {CLK( 2 ); break;}
	case 0xe0: {CPX( A_IMM ); CLK( 2 ); break;}
	case 0xe1: {SBC( A_IX ); CLK( 6 ); break;}
	case 0xe2: {PC++; CLK( 2 ); break;}
	case 0xe3: {CLK( 2 ); break;}
	case 0xe4: {CPX( A_ZP ); CLK( 3 ); break;}
	case 0xe5: {SBC( A_ZP ); CLK( 3 ); break;}
	case 0xe6: {INC( AA_ZP ); CLK( 5 ); break;}
	case 0xe7: {CLK( 2 ); break;}
	case 0xe8: {++X; TEST( X ); CLK( 2 ); break;}
	case 0xe9: {SBC( A_IMM ); CLK( 2 ); break;}
	case 0xea: {CLK( 2 ); break;}
	case 0xeb: {CLK( 2 ); break;}
	case 0xec: {CPX( A_ABS ); CLK( 4 ); break;}
	case 0xed: {SBC( A_ABS ); CLK( 4 ); break;}
	case 0xee: {INC( AA_ABS ); CLK( 6 ); break;}
	case 0xef: {CLK( 2 ); break;}
	case 0xf0: {BRA( F & FLAG_Z ); break;}
	case 0xf1: {SBC( A_IY ); CLK( 5 ); break;}
	case 0xf2: {CLK( 2 ); break;}
	case 0xf3: {CLK( 2 ); break;}
	case 0xf4: {PC++; CLK( 4 ); break;}
	case 0xf5: {SBC( A_ZPX ); CLK( 4 ); break;}
	case 0xf6: {INC( AA_ZPX ); CLK( 6 ); break;}
	case 0xf7: {CLK( 2 ); break;}
	case 0xf8: {SETF( FLAG_D ); CLK( 2 ); break;}
	case 0xf9: {SBC( A_ABSY ); CLK( 4 ); break;}
	case 0xfa: {CLK( 2 ); break;}
	case 0xfb: {CLK( 2 ); break;}
	case 0xfc: {PC+=2; CLK( 4 ); break;}
	case 0xfd: {SBC( A_ABSX ); CLK( 4 ); break;}
	case 0xfe: {INC( AA_ABSX ); CLK( 7 ); break;}
	case 0xff: {CLK( 2 ); break;}
}

    // Execute an instruction.
    //switch ( byCode )
      /* end of switch ( byCode ) */

  }  /* end of while ... */

 //   K6502_i
  // Correct the number of the clocks
  
  g_wPassedClocks -= wClocks;
}

// Addressing Op.
// Data
// Absolute,X
__nes_code static inline BYTE K6502_ReadAbsX(){ WORD wA0, wA1; wA0 = AA_ABS; wA1 = wA0 + X; CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) ); return K6502_Read( wA1 ); };
// Absolute,Y
__nes_code static inline BYTE K6502_ReadAbsY(){ WORD wA0, wA1; wA0 = AA_ABS; wA1 = wA0 + Y; CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) ); return K6502_Read( wA1 ); };
// (Indirect),Y
__nes_code static inline BYTE K6502_ReadIY(){ WORD wA0, wA1; wA0 = K6502_ReadZpW( ROMBANK[(PC>>13)&0x3][(PC++)&0x1fff]/*K6502_Read( PC++ )*/ ); wA1 = wA0 + Y; CLK( ( wA0 & 0x0100 ) != ( wA1 & 0x0100 ) ); return K6502_Read( wA1 ); };

/*===================================================================*/
/*                                                                   */
/*                  6502 Reading/Writing Operation                   */
/*                                                                   */
/*===================================================================*/
#include "K6502_rw.h"
