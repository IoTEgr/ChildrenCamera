/*===================================================================*/
/*                                                                   */
/*  K6502_RW.h : 6502 Reading/Writing Operation for NES              */
/*               This file is included in K6502.cpp                  */
/*                                                                   */
/*  2000/5/23   InfoNES Project ( based on pNesX )                   */
/*                                                                   */
/*===================================================================*/

#ifndef K6502_RW_H_INCLUDED
#define K6502_RW_H_INCLUDED

/*-------------------------------------------------------------------*/
/*  Include files                                                    */
/*-------------------------------------------------------------------*/

#include "InfoNES.h"
#include "InfoNES_System.h"
#include "InfoNES_pAPU.h"

extern WORD g_wPassedClocks;
//typedef struct _funcById0_1
//{
//	WORD id;
//	void (*func)(BYTE byData );
//}funcById0_1;
//static void func0_1( BYTE byData )
//{
//}
//typedef struct _funcById0_2
//{
//	WORD id;
//	void (*func)(WORD wAddr, BYTE byData );
//}funcById0_2;
//
//static void func0_2( WORD wAddr, BYTE byData )
//{
//}
//
//typedef struct _funcById1_1
//{
//	WORD id;
//	BYTE (*func)( WORD wAddr );
//}funcById1_1;

#define FAST_FUNC	1
/*===================================================================*/
/*                                                                   */
/*            K6502_ReadZp() : Reading from the zero page            */
/*                                                                   */
/*===================================================================*/
//#if FAST_FUNC == 0
//static inline BYTE K6502_ReadZp( BYTE byAddr )
//{
///*
// *  Reading from the zero page
// *
// *  Parameters
// *    BYTE byAddr              (Read)
// *      An address inside the zero page
// *
// *  Return values
// *    Read Data
// */
//
//  return RAM[ byAddr ];
//}
//#else
#define K6502_ReadZp(  byAddr )   (RAM[ (BYTE)byAddr])
//#endif
//static inline BYTE K6502_ReadFunc00( WORD wAddr )
//{
//	return RAM[ wAddr & 0x7ff ];
//}
//static inline BYTE K6502_ReadFunc02_7( WORD wAddr )
//{
//	BYTE byRet;
//	WORD addr = PPU_Addr & 0x3fff;
//    // Set return value;
//	byRet = PPU_R7;
//    // Increment PPU Address
//    PPU_Addr += PPU_Increment;
//    // Read PPU Memory
//    PPU_R7 = PPUBANK[ addr >> 10 ][ addr & 0x3ff ];
//    return byRet;
//}
//static inline BYTE K6502_ReadFunc02_4( WORD wAddr )
//{
//	return SPRRAM[ PPU_R3++ ];
//}
//static  inline BYTE K6502_ReadFunc02_2( WORD wAddr )
//{
//	BYTE byRet;
//	// Set return value
//    byRet = PPU_R2;
//#if 0
//    // Reset a V-Blank flag
//    PPU_R2 &= ~R2_IN_VBLANK;
//#endif
//    // Reset address latch
//    PPU_Latch_Flag = 0;
//    // Make a Nametable 0 in V-Blank
//    if ( PPU_Scanline >= SCAN_VBLANK_START && !( PPU_R0 & R0_NMI_VB ) )
//    {
//      PPU_R0 &= ~R0_NAME_ADDR;
//      PPU_NameTableBank = NAME_TABLE0;
//    }
//    return byRet;
//}
//static inline BYTE K6502_ReadFunc02_Default( WORD wAddr )
//{
//	return PPU_R7;
//}
//
//static funcById1_1 K6502_ReadFunc02[]=
//{
//	{0x00,K6502_ReadFunc02_Default},
//	{0x01,K6502_ReadFunc02_Default},
//	{0x02,K6502_ReadFunc02_2},
//	{0x03,K6502_ReadFunc02_Default},
//	{0x04,K6502_ReadFunc02_4},
//	{0x05,K6502_ReadFunc02_Default},
//	{0x06,K6502_ReadFunc02_Default},
//	{0x07,K6502_ReadFunc02_7},
//};
//
//static inline BYTE K6502_ReadFunc02f( WORD wAddr )
//{
////	WORD id=wAddr&0x7;
//	 return K6502_ReadFunc02[wAddr&0x7].func( wAddr);
//}
//
//static inline BYTE K6502_ReadFunc04_4( WORD wAddr )
//{
//	return wAddr & 0xff;
//}
//static inline BYTE K6502_ReadFunc04_5( WORD wAddr )
//{
//	BYTE byRet;
//	 // APU control
//	    byRet = APU_Reg[ 0x15 ];
//		if ( ApuC1Atl > 0 ) 
//			byRet |= (1<<0);
//		if ( ApuC2Atl > 0 ) 
//			byRet |= (1<<1);
//		if (  !ApuC3Holdnote ) 
//		{
//		  if ( ApuC3Atl > 0 ) 
//		  	byRet |= (1<<2);
//		} 
//		else 
//		{
//		  if ( ApuC3Llc > 0 ) 
//		  	byRet |= (1<<2);
//		}
//		if ( ApuC4Atl > 0 ) 
//			byRet |= (1<<3);
//
//		// FrameIRQ
//		APU_Reg[ 0x15 ] &= ~0x40;
//		return byRet;
//		//return APU_Reg[ 0x15 ];
//}
//static inline BYTE K6502_ReadFunc04_6( WORD wAddr )
//{
//	BYTE byRet;
//	// Set Joypad1 data
//    byRet = (BYTE)( ( PAD1_Latch >> PAD1_Bit ) & 1 ) | 0x40;
//    PAD1_Bit = ( PAD1_Bit == 23 ) ? 0 : ( PAD1_Bit + 1 );
//    return byRet;
//}
//static inline BYTE K6502_ReadFunc04_7( WORD wAddr )
//{
//	BYTE byRet;
// // Set Joypad2 data
//    byRet = (BYTE)( ( PAD2_Latch >> PAD2_Bit ) & 1 ) | 0x40;
//    PAD2_Bit = ( PAD2_Bit == 23 ) ? 0 : ( PAD2_Bit + 1 );
//    return byRet;
//}
//static BYTE K6502_ReadFunc04_Default( WORD wAddr )
//{
//	return MapperReadApu( wAddr );
//}
//
//static funcById1_1 K6502_ReadFunc04[]=
//{
//	{0x00,K6502_ReadFunc04_Default},
//	{0x01,K6502_ReadFunc04_Default},
//	{0x02,K6502_ReadFunc04_Default},
//	{0x03,K6502_ReadFunc04_Default},
//	{0x04,K6502_ReadFunc04_4},
//	{0x05,K6502_ReadFunc04_5},
//	{0x06,K6502_ReadFunc04_6},
//	{0x07,K6502_ReadFunc04_7},
//	{0x08,K6502_ReadFunc04_Default},
//	{0x09,K6502_ReadFunc04_Default},
//	{0x0a,K6502_ReadFunc04_Default},
//	{0x0b,K6502_ReadFunc04_Default},
//	{0x0c,K6502_ReadFunc04_Default},
//	{0x0d,K6502_ReadFunc04_Default},
//	{0x0e,K6502_ReadFunc04_Default},
//	{0x0f,K6502_ReadFunc04_Default},
//};
//static BYTE K6502_ReadFunc04f( WORD wAddr )
//{
//	if((wAddr&0x4010)==0x4010)
//	{
//		WORD id=wAddr&0xf;
//		 return K6502_ReadFunc04[id].func( wAddr);
//	}
//	else
//	{
//		return MapperReadApu( wAddr );
//	}
//}
//static inline BYTE K6502_ReadFunc06( WORD wAddr )
//{
//	if ( ROM_SRAM )
//      {
//        return SRAM[ wAddr & 0x1fff ];
//      } else {    /* SRAM BANK */
//        return SRAMBANK[ wAddr & 0x1fff ];
//      }
//}
//static inline BYTE K6502_ReadFunc08( WORD wAddr )
//{
//	return ROMBANK0[ wAddr & 0x1fff ];
//}
//static inline BYTE K6502_ReadFunc0a( WORD wAddr )
//{
//	return ROMBANK1[ wAddr & 0x1fff ];
//}
//static inline BYTE K6502_ReadFunc0c( WORD wAddr )
//{
//	return ROMBANK2[ wAddr & 0x1fff ];
//}
//static inline BYTE K6502_ReadFunc0e( WORD wAddr )
//{
//	return ROMBANK3[ wAddr & 0x1fff ];
//}
//static inline BYTE K6502_ReadFuncDefault( WORD wAddr )
//{
//	return ( wAddr >> 8 );
//}
//
//static funcById1_1 K6502_ReadFunc[]=
//{
//	{0x00,K6502_ReadFunc00},
//	{0x01,K6502_ReadFunc02f},
//	{0x02,K6502_ReadFunc04f},
//	{0x03,K6502_ReadFunc06},
//	{0x04,K6502_ReadFunc08},
//	{0x05,K6502_ReadFunc0a},
//	{0x06,K6502_ReadFunc0c},
//	{0x07,K6502_ReadFunc0e}
//};
/*===================================================================*/
/*                                                                   */
/*               K6502_Read() : Reading operation                    */
/*                                                                   */
/*===================================================================*/
//#if FAST_FUNC == 0
//static inline BYTE K6502_Read( WORD wAddr )
//{
///*
// *  Reading operation
// *
// *  Parameters
// *    WORD wAddr              (Read)
// *      Address to read
// *
// *  Return values
// *    Read data
// *
// *  Remarks
// *    0x0000 - 0x1fff  RAM ( 0x800 - 0x1fff is mirror of 0x0 - 0x7ff )
// *    0x2000 - 0x3fff  PPU
// *    0x4000 - 0x5fff  Sound
// *    0x6000 - 0x7fff  SRAM ( Battery Backed )
// *    0x8000 - 0xffff  ROM
// *
// */
// //WORD id=wAddr>>13;
// return K6502_ReadFunc[wAddr>>13].func( wAddr);
// // switch ( wAddr & 0xe000 )
//
//}
//#else
enum{
	RAM_DATA 	= 0x00,
	PPU_DATA 	= 0x01,
	PAPU_DATA	= 0x02,
	SRAM_DATA	= 0x03,
	ROM_DATA0	= 0x04,
	ROM_DATA1	= 0x05,
	ROM_DATA2	= 0x06,
	ROM_DATA3	= 0x07,
};
//static inline BYTE K6502_Read_ROM( WORD wAddr )
//{
//	switch((wAddr>>13))
//	{
//	case ROM_DATA0:
//		return ROMBANK0[ wAddr & 0x1fff ];
//		break;
//	case ROM_DATA1:
//		return ROMBANK1[ wAddr & 0x1fff ];
//		break;
//	case ROM_DATA2:
//		return ROMBANK2[ wAddr & 0x1fff ];
//		break;
//	case ROM_DATA3:
//		return ROMBANK3[ wAddr & 0x1fff ];
//		break;
//	default:
//		return 0;
//	}
//}

__nes_code static inline BYTE K6502_Read( WORD wAddr )
{
/*
 *  Reading operation
 *
 *  Parameters
 *    WORD wAddr              (Read)
 *      Address to read
 *
 *  Return values
 *    Read data
 *
 *  Remarks
 *    0x0000 - 0x1fff  RAM ( 0x800 - 0x1fff is mirror of 0x0 - 0x7ff )
 *    0x2000 - 0x3fff  PPU
 *    0x4000 - 0x5fff  Sound
 *    0x6000 - 0x7fff  SRAM ( Battery Backed )
 *    0x8000 - 0xffff  ROM
 *
 */
 BYTE id = wAddr>>13;  //8K
 BYTE ppu_indx =  wAddr & 0x07;
 BYTE papu_indx = wAddr & 0x0f;
 BYTE byRet;
 switch (id)
 {
	case RAM_DATA:	
		return RAM[ wAddr & 0x7ff ]; break;
	case PPU_DATA:
	{
		switch (ppu_indx)
		{
			case 0x02:
				// Set return value
				byRet = PPU_R2;
				// Reset address latch
				PPU_Latch_Flag = 0;
				// Make a Nametable 0 in V-Blank
				if ( PPU_Scanline >= SCAN_VBLANK_START && !( PPU_R0 & R0_NMI_VB ) )
				{
				  PPU_R0 &= ~R0_NAME_ADDR;
				  PPU_NameTableBank = NAME_TABLE0;
				}
				return byRet; break;
			case 0x04:
				return SPRRAM[ PPU_R3++ ]; break;
			case 0x07:
			{
				WORD addr = PPU_Addr & 0x3fff;
				// Set return value;
				byRet = PPU_R7;
				// Increment PPU Address
				PPU_Addr += PPU_Increment;
				// Read PPU Memory
				PPU_R7 = PPUBANK[ addr >> 10 ][ addr & 0x3ff ];
				return byRet;	break;
			}
			default:
				return PPU_R7; break;
		}
	}
		//return K6502_ReadFunc02[wAddr&0x7].func( wAddr); break;
	case PAPU_DATA:
		if((wAddr&0x4010)==0x4010)
		{
			switch (papu_indx)
			{
				case 0x04:
					return wAddr & 0xff; break;
				case 0x05:
				{
					// APU control
					byRet = APU_Reg[ 0x15 ];
					if ( ApuC1Atl > 0 ) 
						byRet |= (1<<0);
					if ( ApuC2Atl > 0 ) 
						byRet |= (1<<1);
					if (  !ApuC3Holdnote ) 
					{
					  if ( ApuC3Atl > 0 ) 
						byRet |= (1<<2);
					} 
					else 
					{
					  if ( ApuC3Llc > 0 ) 
						byRet |= (1<<2);
					}
					if ( ApuC4Atl > 0 ) 
						byRet |= (1<<3);
					if(ApyC5_irq_occurred)
						byRet |= 0x80;
					// FrameIRQ
					APU_Reg[ 0x15 ] &= ~0x40;
					return byRet; break;
					//return APU_Reg[ 0x15 ]; break;	
				}
					
				case 0x06:
				{
					byRet = (BYTE)( ( PAD1_Latch >> PAD1_Bit ) & 1 ) | 0x40;
					PAD1_Bit = ( PAD1_Bit == 23 ) ? 0 : ( PAD1_Bit + 1 );
					return byRet; break;
				}	
				case 0x07:
				{
					// Set Joypad2 data
					byRet = (BYTE)( ( PAD2_Latch >> PAD2_Bit ) & 1 ) | 0x40;
					PAD2_Bit = ( PAD2_Bit == 23 ) ? 0 : ( PAD2_Bit + 1 );
					return byRet; break;
				}	
				default:
					return MapperReadApu( wAddr ); break;
			}
			// return K6502_ReadFunc04[wAddr&0xf].func( wAddr);
		}
		else
		{
			return MapperReadApu( wAddr );
		}
		break;
	case SRAM_DATA:
		if ( ROM_SRAM )
		{
			return SRAM[ wAddr & 0x1fff ];
		} else 
		{    /* SRAM BANK */
			return SRAMBANK[ wAddr & 0x1fff ];
		}
		break;
	//debg("++");
	case ROM_DATA0:
		return ROMBANK0[ wAddr & 0x1fff ];
		break;
	case ROM_DATA1:
		return ROMBANK1[ wAddr & 0x1fff ];
		break;
	case ROM_DATA2:
		return ROMBANK2[ wAddr & 0x1fff ];
		break;
	case ROM_DATA3:
		return ROMBANK3[ wAddr & 0x1fff ];
		break;
	default:
		return 0;
 }
 //return K6502_ReadFunc[wAddr>>13].func( wAddr);
 // switch ( wAddr & 0xe000 )

}
//#if FAST_FUNC == 1
__nes_code static inline WORD K6502_ReadW2( WORD wAddr )
{
/*
 *  Reading operation
 *
 *  Parameters
 *    WORD wAddr              (Read)
 *      Address to read
 *
 *  Return values
 *    Read data
 *
 *  Remarks
 *    0x0000 - 0x1fff  RAM ( 0x800 - 0x1fff is mirror of 0x0 - 0x7ff )
 *    0x2000 - 0x3fff  PPU
 *    0x4000 - 0x5fff  Sound
 *    0x6000 - 0x7fff  SRAM ( Battery Backed )
 *    0x8000 - 0xffff  ROM
 *
 */
	BYTE id = wAddr>>13;  //8K

	WORD wAddr_next = 0;
	if(0x00ff == (wAddr&0x00ff))
	{
		wAddr_next = wAddr - 0x00ff;
	}
	else
	{
		wAddr_next = wAddr + 1;
	}
	switch (id)
	{
		case RAM_DATA:	
			return RAM[ wAddr & 0x7ff ]|(RAM[ wAddr_next & 0x7ff ]<<8); break;
		case PPU_DATA:
		{
			return K6502_Read(wAddr)|(K6502_Read(wAddr_next)<<8);
			break;
		}
			//return K6502_ReadFunc02[wAddr&0x7].func( wAddr); break;
		case PAPU_DATA:
		{
			return K6502_Read(wAddr)|(K6502_Read(wAddr_next)<<8);
			break;
		}
		
		case SRAM_DATA:
			if ( ROM_SRAM )
			{
				return SRAM[ wAddr & 0x1fff ]|(SRAM[ wAddr_next & 0x1fff ]<<8);
			} else 
			{    /* SRAM BANK */
				return SRAMBANK[ wAddr & 0x1fff ]|(SRAMBANK[ wAddr_next & 0x1fff ]<<8);
			}
			break;
		case ROM_DATA0:
			return ROMBANK0[ wAddr & 0x1fff ]|(ROMBANK0[ wAddr_next & 0x1fff ]<<8);
			break;
		case ROM_DATA1:
			return ROMBANK1[ wAddr & 0x1fff ]|(ROMBANK1[ wAddr_next & 0x1fff ]<<8);
			break;
		case ROM_DATA2:
			return ROMBANK2[ wAddr & 0x1fff ]|(ROMBANK2[ wAddr_next & 0x1fff ]<<8);
			break;
		case ROM_DATA3:
			return ROMBANK3[ wAddr & 0x1fff ]|(ROMBANK3[ wAddr_next & 0x1fff ]<<8);
			break;
		default:
			return 0;
	}
 //return K6502_ReadFunc[wAddr>>13].func( wAddr);
 // switch ( wAddr & 0xe000 )

}	
//#endif
//#endif
/*===================================================================*/
/*                                                                   */
/*               K6502_Write() : Writing operation                    */
/*                                                                   */
/*===================================================================*/ 
//static inline void K6502_Write0_2_0000( WORD wAddr, BYTE byData )
//{
//	RAM[ wAddr & 0x7ff ] = byData;
//}
//
//static inline void K6502_Write2000_0( WORD wAddr, BYTE byData )
//{
//	PPU_R0 = byData;
//	PPU_Increment = ( PPU_R0 & R0_INC_ADDR ) ? 32 : 1;
//	PPU_NameTableBank = NAME_TABLE0 + ( PPU_R0 & R0_NAME_ADDR );
//	PPU_BG_Base = ( PPU_R0 & R0_BG_ADDR ) ? (ChrBuf + 256 * 64) : ChrBuf;
//	PPU_SP_Base = ( PPU_R0 & R0_SP_ADDR ) ? (ChrBuf + 256 * 64) : ChrBuf;
//	PPU_SP_Height = ( PPU_R0 & R0_SP_SIZE ) ? 16 : 8;
//
//	// Account for Loopy's scrolling discoveries
//	PPU_Temp = ( PPU_Temp & 0xF3FF ) | ( ( ( (WORD)byData ) & 0x0003 ) << 10 );
//}
//static inline void K6502_Write2000_1( WORD wAddr, BYTE byData )
//{
//	PPU_R1 = byData;
//}
//static inline void K6502_Write2000_3( WORD wAddr, BYTE byData )
//{
//	// Sprite RAM Address
//	      PPU_R3 = byData;
//}
//static inline void K6502_Write2000_4( WORD wAddr, BYTE byData )
//{
//	 // Write data to Sprite RAM
//	 SPRRAM[ PPU_R3++ ] = byData;
//}
//static inline void K6502_Write2000_5( WORD wAddr, BYTE byData )
//{
//	// Set Scroll Register
//	  if ( PPU_Latch_Flag )
//	  {
//	    // V-Scroll Register
//	    PPU_Scr_V_Next = ( byData > 239 ) ? (byData - 240 ): byData;	    
//	if ( byData > 239 ) PPU_NameTableBank ^= NAME_TABLE_V_MASK; 
//	    PPU_Scr_V_Byte_Next = PPU_Scr_V_Next >> 3;
//	    PPU_Scr_V_Bit_Next = PPU_Scr_V_Next & 7;
//
//	    // Added : more Loopy Stuff
//	PPU_Temp = ( PPU_Temp & 0xFC1F ) | ( ( ( (WORD)byData ) & 0xF8 ) << 2);
//	PPU_Temp = ( PPU_Temp & 0x8FFF ) | ( ( ( (WORD)byData ) & 0x07 ) << 12);
//	  }
//	  else
//	  {
//	    // H-Scroll Register
//	    PPU_Scr_H_Next = byData;
//	    PPU_Scr_H_Byte_Next = PPU_Scr_H_Next >> 3;
//	    PPU_Scr_H_Bit_Next = PPU_Scr_H_Next & 7;
//
//	    // Added : more Loopy Stuff
//	PPU_Temp = ( PPU_Temp & 0xFFE0 ) | ( ( ( (WORD)byData ) & 0xF8 ) >> 3 );
//	  }
//	  PPU_Latch_Flag ^= 1;
//}
//static inline void K6502_Write2000_6( WORD wAddr, BYTE byData )
//{
//	 // Set PPU Address
//	      if ( PPU_Latch_Flag )
//	      {
//	        /* Low */
//#if 0
//	        PPU_Addr = ( PPU_Addr & 0xff00 ) | ( (WORD)byData );
//#else
//	        PPU_Temp = ( PPU_Temp & 0xFF00 ) | ( ( (WORD)byData ) & 0x00FF);
//	    PPU_Addr = PPU_Temp;
//#endif
//	    if ( !( PPU_R2 & R2_IN_VBLANK ) ) {
//	      InfoNES_SetupScr();
//	    }
//	      }
//	      else
//	      {
//	        /* High */
//#if 0
//	        PPU_Addr = ( PPU_Addr & 0x00ff ) | ( (WORD)( byData & 0x3f ) << 8 );
//	        InfoNES_SetupScr();
//#else
//	        PPU_Temp = ( PPU_Temp & 0x00FF ) | ( ( ((WORD)byData) & 0x003F ) << 8 );
//#endif            
//	      }
//	      PPU_Latch_Flag ^= 1;
//}
//static inline void K6502_Write2000_7( WORD wAddr, BYTE byData )
//{
//	WORD addr = PPU_Addr;
//	        
//        // Increment PPU Address
//        PPU_Addr += PPU_Increment;
//        addr &= 0x3fff;
//
//        // Write to PPU Memory
//        if ( addr < 0x2000 && byVramWriteEnable )
//        {
//          // Pattern Data
//          ChrBufUpdate |= ( 1 << ( addr >> 10 ) );
//          PPUBANK[ addr >> 10 ][ addr & 0x3ff ] = byData;
//        }
//        else if ( addr < 0x3f00 )  /* 0x2000 - 0x3eff */
//        {
//          // Name Table and mirror
//          PPUBANK[   addr            >> 10 ][ addr & 0x3ff ] = byData;
//          PPUBANK[ ( addr ^ 0x1000 ) >> 10 ][ addr & 0x3ff ] = byData;
//        }
//        else if ( !( addr & 0xf ) )  /* 0x3f00 or 0x3f10 */
//        {
//          // Palette mirror
//          PPURAM[ 0x3f10 ] = PPURAM[ 0x3f14 ] = PPURAM[ 0x3f18 ] = PPURAM[ 0x3f1c ] = 
//          PPURAM[ 0x3f00 ] = PPURAM[ 0x3f04 ] = PPURAM[ 0x3f08 ] = PPURAM[ 0x3f0c ] = byData;
//          PalTable[ 0x00 ] = PalTable[ 0x04 ] = PalTable[ 0x08 ] = PalTable[ 0x0c ] =
//          PalTable[ 0x10 ] = PalTable[ 0x14 ] = PalTable[ 0x18 ] = PalTable[ 0x1c ] = byData;//NesPalette[ byData ] | 0x8000;
//        }
//        else if ( addr & 3 )
//        {
//          // Palette
//          PPURAM[ addr ] = byData;
//          PalTable[ addr & 0x1f ] = byData;//NesPalette[ byData ];
//        }
//}
//static funcById0_2 K6502_Write2000[]=
//{
//	{0x00,K6502_Write2000_0},
//	{0x01,K6502_Write2000_1},
//	{0x02,func0_2}, //PPU_R2 = byData;     // 0x2002 is not writable
//	{0x03,K6502_Write2000_3},
//	{0x04,K6502_Write2000_4},
//	{0x05,K6502_Write2000_5},
//	{0x06,K6502_Write2000_6},
//	{0x07,K6502_Write2000_7},
//};
//static inline void K6502_Write0_2_2000( WORD wAddr, BYTE byData )
//{
//	WORD id=wAddr & 0x7;
//	if(id<sizeof(K6502_Write2000)/sizeof(K6502_Write2000[0]))
//		K6502_Write2000[id].func( wAddr,  byData);
//	// switch ( wAddr & 0x7 )
//}
//
//
//static inline void K6502_Write4000_0( WORD wAddr, BYTE byData )
//{
//	// Call Function corresponding to Sound Registers
//	WORD id=wAddr&0x1f;
//	if ( !APU_Mute&&id<20 )
//		pAPUSoundRegs[ id ]( wAddr, byData );
//	
//}
//
//static inline void K6502_Write4000_14_0( BYTE byData )
//{
//	InfoNES_MemoryCopy( SPRRAM, &RAM[ ( (WORD)byData << 8 ) & 0x7ff ], SPRRAM_SIZE );
//}
//static inline void K6502_Write4000_14_3( BYTE byData )
//{
//	InfoNES_MemoryCopy( SPRRAM, &SRAM[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
//}
//static inline void K6502_Write4000_14_4( BYTE byData )
//{
//	InfoNES_MemoryCopy( SPRRAM, &ROMBANK0[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
//}
//static inline void K6502_Write4000_14_5( BYTE byData )
//{
//	InfoNES_MemoryCopy( SPRRAM, &ROMBANK1[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
//}
//static inline void K6502_Write4000_14_6( BYTE byData )
//{
//	InfoNES_MemoryCopy( SPRRAM, &ROMBANK2[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
//}
//static inline void K6502_Write4000_14_7( BYTE byData )
//{
//	InfoNES_MemoryCopy( SPRRAM, &ROMBANK3[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
//}
//static funcById0_1 K6502_Write4000_14[]=
//{
//	{0x00,K6502_Write4000_14_0},
//	{0x01,func0_1},
//	{0x02,func0_1}, 
//	{0x03,K6502_Write4000_14_3},
//	{0x04,K6502_Write4000_14_4},
//	{0x05,K6502_Write4000_14_5},
//	{0x06,K6502_Write4000_14_6},
//	{0x07,K6502_Write4000_14_7},
//};
//static inline void K6502_Write4000_14f( WORD wAddr, BYTE byData )
//{
//WORD id= byData >> 5 ;
//if(id<sizeof(K6502_Write4000_14)/sizeof(K6502_Write4000_14[0]))
//	K6502_Write4000_14[id].func(  byData);
//         // switch ( byData >> 5 )
//
//}
//static inline void K6502_Write4000_15( WORD wAddr, BYTE byData )
//{
//	 InfoNES_pAPUWriteControl( wAddr, byData );
//#if 0
//          /* Unknown */
//          if ( byData & 0x10 ) 
//          {
//	    byData &= ~0x80;
//	  }
//#endif
//}
//static inline void K6502_Write4000_16( WORD wAddr, BYTE byData )
//{
//	 // For VS-Unisystem
//	  MapperApu( wAddr, byData );
//          // Reset joypad
//          if ( !( APU_Reg[ 0x16 ] & 1 ) && ( byData & 1 ) )
//          {
//            PAD1_Bit = 0;
//            PAD2_Bit = 0;
//          }
//}
//static inline void K6502_Write4000_17( WORD wAddr, BYTE byData )
//{
//	// Frame IRQ
//          FrameStep = 0;
//          if ( !( byData & 0xc0 ) )
//          {
//            FrameIRQ_Enable = 1;
//          } else {
//            FrameIRQ_Enable = 0;
//          }
//}
//static funcById0_2 K6502_Write4000[]=
//{
//	{0x00,K6502_Write4000_0},
//	{0x01,K6502_Write4000_0},
//	{0x02,K6502_Write4000_0}, 
//	{0x03,K6502_Write4000_0},
//	{0x04,K6502_Write4000_0},
//	{0x05,K6502_Write4000_0},
//	{0x06,K6502_Write4000_0},
//	{0x07,K6502_Write4000_0},
//	{0x08,K6502_Write4000_0},
//	{0x09,K6502_Write4000_0},
//	{0x0a,K6502_Write4000_0}, 
//	{0x0b,K6502_Write4000_0},
//	{0x0c,K6502_Write4000_0},
//	{0x0d,K6502_Write4000_0},
//	{0x0e,K6502_Write4000_0},
//	{0x0f,K6502_Write4000_0},
//	{0x10,K6502_Write4000_0},
//	{0x11,K6502_Write4000_0},
//	{0x12,K6502_Write4000_0}, 
//	{0x13,K6502_Write4000_0},
//	{0x14,K6502_Write4000_14f},
//	{0x15,K6502_Write4000_15},
//	{0x16,K6502_Write4000_16},
//	{0x17,K6502_Write4000_17},
//	{0x18,func0_2},
//	{0x19,func0_2},
//	{0x1a,func0_2},
//	{0x1b,func0_2},
//	{0x1c,func0_2},
//	{0x1d,func0_2},
//	{0x1e,func0_2},
//	{0x1f,func0_2},
//};
//static inline void K6502_Write0_2_4000( WORD wAddr, BYTE byData )
//{
//	WORD id= wAddr & 0x1f;
////if(id<sizeof(K6502_Write4000)/sizeof(K6502_Write4000[0]))
//	K6502_Write4000[id].func( wAddr,  byData);
//     // switch ( wAddr & 0x1f )
//
//      if ( wAddr <= 0x4017 )
//      {
//        /* Write to APU Register */
//		if(id<0x18)
//        APU_Reg[ id ] = byData;
//      }
//      else
//      {
//        /* Write to APU */
//        MapperApu( wAddr, byData );
//      }
//}
//static inline void K6502_Write0_2_6000( WORD wAddr, BYTE byData )
//{
//	SRAM[ wAddr & 0x1fff ] = byData;
//      /* Write to SRAM, when no SRAM */
//      if ( !ROM_SRAM )
//      {
//        MapperSram( wAddr, byData );
//      }
//}
//static inline void K6502_Write0_2_8000( WORD wAddr, BYTE byData )
//{
//	MapperWrite( wAddr, byData );
//}
//
//static funcById0_2 K6502_Write0_2[]=
//{
//	{0x00,K6502_Write0_2_0000},
//	{0x01,K6502_Write0_2_2000},
//	{0x02,K6502_Write0_2_4000},
//	{0x03,K6502_Write0_2_6000},
//	{0x04,K6502_Write0_2_8000},
//	{0x05,K6502_Write0_2_8000},
//	{0x06,K6502_Write0_2_8000},
//	{0x07,K6502_Write0_2_8000}
//};

//#if FAST_FUNC == 0
//static inline void K6502_Write( WORD wAddr, BYTE byData )
//{
///*
// *  Writing operation
// *
// *  Parameters
// *    WORD wAddr              (Read)
// *      Address to write
// *
// *    BYTE byData             (Read)
// *      Data to write
// *
// *  Remarks
// *    0x0000 - 0x1fff  RAM ( 0x800 - 0x1fff is mirror of 0x0 - 0x7ff )
// *    0x2000 - 0x3fff  PPU
// *    0x4000 - 0x5fff  Sound
// *    0x6000 - 0x7fff  SRAM ( Battery Backed )
// *    0x8000 - 0xffff  ROM
// *
// */
////WORD id=wAddr>>13;
////if(id<sizeof(K6502_Write0_2)/sizeof(K6502_Write0_2[0]))
//	K6502_Write0_2[wAddr>>13].func( wAddr,  byData);
////  switch ( wAddr & 0xe000 )
//
//}
//#else
__nes_code static inline void K6502_Write( WORD wAddr, BYTE byData )
{
/*
 *  Writing operation
 *
 *  Parameters
 *    WORD wAddr              (Read)
 *      Address to write
 *
 *    BYTE byData             (Read)
 *      Data to write
 *
 *  Remarks
 *    0x0000 - 0x1fff  RAM ( 0x800 - 0x1fff is mirror of 0x0 - 0x7ff )
 *    0x2000 - 0x3fff  PPU
 *    0x4000 - 0x5fff  Sound
 *    0x6000 - 0x7fff  SRAM ( Battery Backed )
 *    0x8000 - 0xffff  ROM
 *
 */

	BYTE id = wAddr>>13;  //8K
	BYTE ppu_indx = wAddr & 0x7;
	BYTE papa_indx = wAddr & 0x1f;
	switch(id)
	{
		case 0x00://RAM_DATA:
			RAM[ wAddr & 0x7ff ] = byData; 
			break;
		case 0x01:
		{
			switch(ppu_indx)
			{
				case 0x00: //PPU_R0
				{
					PPU_R0 = byData;
					PPU_Increment = ( PPU_R0 & R0_INC_ADDR ) ? 32 : 1;
					PPU_NameTableBank = NAME_TABLE0 + ( PPU_R0 & R0_NAME_ADDR );
					PPU_BG_Base = ( PPU_R0 & R0_BG_ADDR ) ? ChrBuf + 256 * 64 : ChrBuf;
					PPU_SP_Base = ( PPU_R0 & R0_SP_ADDR ) ? ChrBuf + 256 * 64 : ChrBuf;
					PPU_SP_Height = ( PPU_R0 & R0_SP_SIZE ) ? 16 : 8;

					// Account for Loopy's scrolling discoveries
					PPU_Temp = ( PPU_Temp & 0xF3FF ) | ( ( ( (WORD)byData ) & 0x0003 ) << 10 );
					break;
				}
				case 0x01://PPU_R1
					PPU_R1 = byData;
					break;
				case 0x02://PPU_R2
				//	func0_2(wAddr,byData);
					break;
				case 0x03://PPU_R3
					// Sprite RAM Address
					PPU_R3 = byData;
					break;
				case 0x04://PPU_R4
					// Write data to Sprite RAM
					SPRRAM[ PPU_R3++ ] = byData;
					break;
				case 0x05: //PPU_R5
				{
					// Set Scroll Register
					if ( PPU_Latch_Flag )
					{
						// V-Scroll Register
						PPU_Scr_V_Next = ( byData > 239 ) ? byData - 240 : byData;	    
						if ( byData > 239 ) PPU_NameTableBank ^= NAME_TABLE_V_MASK; 
						PPU_Scr_V_Byte_Next = PPU_Scr_V_Next >> 3;
						PPU_Scr_V_Bit_Next = PPU_Scr_V_Next & 7;

						// Added : more Loopy Stuff
						PPU_Temp = ( PPU_Temp & 0xFC1F ) | ( ( ( (WORD)byData ) & 0xF8 ) << 2);
						PPU_Temp = ( PPU_Temp & 0x8FFF ) | ( ( ( (WORD)byData ) & 0x07 ) << 12);
					}
					else
					{
						// H-Scroll Register
						PPU_Scr_H_Next = byData;
						PPU_Scr_H_Byte_Next = PPU_Scr_H_Next >> 3;
						PPU_Scr_H_Bit_Next = PPU_Scr_H_Next & 7;

						// Added : more Loopy Stuff
						PPU_Temp = ( PPU_Temp & 0xFFE0 ) | ( ( ( (WORD)byData ) & 0xF8 ) >> 3 );
					}
					PPU_Latch_Flag ^= 1;	
				}
				break;
				case 0x06: //PPU_R6
				{
					// Set PPU Address
					if ( PPU_Latch_Flag )
					{
					/* Low */
					#if 0
						PPU_Addr = ( PPU_Addr & 0xff00 ) | ( (WORD)byData );
					#else
						PPU_Temp = ( PPU_Temp & 0xFF00 ) | ( ( (WORD)byData ) & 0x00FF);
						PPU_Addr = PPU_Temp;
					#endif
						if ( !( PPU_R2 & R2_IN_VBLANK ) ) {
							InfoNES_SetupScr();
						}
					}
					else
					{
						/* High */
					#if 0
						PPU_Addr = ( PPU_Addr & 0x00ff ) | ( (WORD)( byData & 0x3f ) << 8 );
						InfoNES_SetupScr();
					#else
						PPU_Temp = ( PPU_Temp & 0x00FF ) | ( ( ((WORD)byData) & 0x003F ) << 8 );
					#endif            
					}
					PPU_Latch_Flag ^= 1;
				}
				break;
				case 0x07://PPU_R7
				{
					WORD addr = PPU_Addr;
	        
					// Increment PPU Address
					PPU_Addr += PPU_Increment;
					addr &= 0x3fff;

					// Write to PPU Memory
					if ( addr < 0x2000 && byVramWriteEnable )
					{
					  // Pattern Data
					  ChrBufUpdate |= ( 1 << ( addr >> 10 ) );
					  PPUBANK[ addr >> 10 ][ addr & 0x3ff ] = byData;
					}
					else if ( addr < 0x3f00 )  /* 0x2000 - 0x3eff */
					{
					  // Name Table and mirror
					  PPUBANK[   addr            >> 10 ][ addr & 0x3ff ] = byData;
					  PPUBANK[ ( addr ^ 0x1000 ) >> 10 ][ addr & 0x3ff ] = byData;
					}
					else if ( !( addr & 0xf ) )  /* 0x3f00 or 0x3f10 */
					{
					  // Palette mirror
					  PPURAM[ 0x3f10 ] = PPURAM[ 0x3f14 ] = PPURAM[ 0x3f18 ] = PPURAM[ 0x3f1c ] = 
					  PPURAM[ 0x3f00 ] = PPURAM[ 0x3f04 ] = PPURAM[ 0x3f08 ] = PPURAM[ 0x3f0c ] = byData;
					  PalTable[ 0x00 ] = PalTable[ 0x04 ] = PalTable[ 0x08 ] = PalTable[ 0x0c ] = 
					  PalTable[ 0x10 ] = PalTable[ 0x14 ] = PalTable[ 0x18 ] = PalTable[ 0x1c ] = byData|0x80;//NesPalette[ byData ] | 0x8000;
					}
					else if ( addr & 3 )
					{
					  // Palette
					  PPURAM[ addr ] = byData;
					  PalTable[ addr & 0x1f ] = byData;//NesPalette[ byData ];
					}	
				}
				break;
				default:
					
					break;
			}
		}
		break;
		case 0x02:
		{

			switch(papa_indx)
			{
				case 0x14:
				{
					BYTE id= (byData >> 5)&0x7 ;
					switch(id)
					{
						case 0x00:
							//ax32xx_mcpy1_sdram2gram_sdr( SPRRAM, &RAM[ ( (WORD)byData << 8 ) & 0x7ff ], SPRRAM_SIZE );
							ax32xx_mcpy1_sdram2gram( SPRRAM, &RAM[ ( (WORD)byData << 8 ) & 0x7ff ], SPRRAM_SIZE );
							break;
						case 0x01:
						case 0x02:
							//func0_1(byData );
							break;
						case 0x03:
							//ax32xx_mcpy1_sdram2gram_sdr( SPRRAM, &SRAM[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
							ax32xx_mcpy1_sdram2gram( SPRRAM, &SRAM[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
							break;
						case 0x04:
							//ax32xx_mcpy1_sdram2gram_sdr( SPRRAM, &ROMBANK0[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
							ax32xx_mcpy1_sdram2gram( SPRRAM, &ROMBANK0[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
							break;
						case 0x05:
							//ax32xx_mcpy1_sdram2gram_sdr( SPRRAM, &ROMBANK1[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
							ax32xx_mcpy1_sdram2gram( SPRRAM, &ROMBANK1[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
							break;
						case 0x06:
							//ax32xx_mcpy1_sdram2gram_sdr( SPRRAM, &ROMBANK2[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
							ax32xx_mcpy1_sdram2gram( SPRRAM, &ROMBANK2[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
							break;
						case 0x07:
							//ax32xx_mcpy1_sdram2gram_sdr( SPRRAM, &ROMBANK3[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
							ax32xx_mcpy1_sdram2gram( SPRRAM, &ROMBANK3[ ( (WORD)byData << 8 ) & 0x1fff ], SPRRAM_SIZE );
							break;
						default:
							break;							
					}
					break;
				}
				case 0x15:
					//K6502_Write4000_15(wAddr, byData );
					//InfoNES_pAPUWriteControl( wAddr, byData );
					ApuEventQueue[cur_event].time = entertime - g_wPassedClocks; 
					ApuEventQueue[cur_event].type = ApuEventType[20]; 
					ApuEventQueue[cur_event].data = byData; 
					cur_event++;
					break;
				case 0x16:
				{
					//K6502_Write4000_16(wAddr, byData );
					MapperApu( wAddr, byData );
					// Reset joypad
					if ( !( APU_Reg[ 0x16 ] & 1 ) && ( byData & 1 ) )
					{
						PAD1_Bit = 0;
						PAD2_Bit = 0;
					}
					break;
					
				}
				case 0x17:
				{
					//K6502_Write4000_17(wAddr, byData );
					FrameStep = 0;
					if ( !( byData & 0xc0 ) )
					{
						FrameIRQ_Enable = 1;
					} else {
						FrameIRQ_Enable = 0;
					}
					break;
					
				}
				case 0x18:
				case 0x19:
				case 0x1a:
				case 0x1b:
				case 0x1c:
				case 0x1d:
				case 0x1e:
				case 0x1f:
				//	func0_2(wAddr, byData );
					break;
				default:
				{
					//K6502_Write4000_0(wAddr, byData );
					BYTE id=wAddr&0x1f;
					if ( !APU_Mute&&id<20 )
					{
						ApuEventQueue[cur_event].time = entertime - g_wPassedClocks; 
						ApuEventQueue[cur_event].type = ApuEventType[id]; 
						ApuEventQueue[cur_event].data = byData; 
						cur_event++;
					}
					break;
					
				}
			}
			if ( wAddr <= 0x4017 )
			{
				/* Write to APU Register */
				if(id<0x18)
					APU_Reg[ id ] = byData;
			}
			else
			{
				/* Write to APU */
				MapperApu( wAddr, byData );
			}
			break;
		}
		//	K6502_Write0_2_4000( wAddr,  byData);
			
		case 0x03:
			SRAM[ wAddr & 0x1fff ] = byData;
			/* Write to SRAM, when no SRAM */
			if ( !ROM_SRAM )
			{
				MapperSram( wAddr, byData );
			}	
			break;
		default:  // ROM_DATA0
			MapperWrite( wAddr, byData );
			break;
	}

//K6502_Write0_2[wAddr>>13].func( wAddr,  byData);
}
//#endif
// Reading/Writing operation (WORD version)
//#if FAST_FUNC == 0
//static inline WORD K6502_ReadW( WORD wAddr ){ return K6502_Read( wAddr ) | (WORD)K6502_Read( wAddr + 1 ) << 8; };
////static inline WORD K6502_ReadW( WORD wAddr ){ return (WORD)ROM[wAddr & PC_MASK]| (ROM[(wAddr + 1) & PC_MASK]<<8); };
//#else
__nes_code static inline WORD K6502_ReadW( WORD wAddr ){ return (WORD)ROMBANK[(wAddr>>13)&0x3][(wAddr)&0x1fff]| (ROMBANK[((wAddr+1)>>13)&0x3][(wAddr+1)&0x1fff]<<8); };
//#endif
//#if FAST_FUNC == 0
//static inline void K6502_WriteW( WORD wAddr, WORD wData ){ K6502_Write( wAddr, wData & 0xff ); K6502_Write( wAddr + 1, wData >> 8 ); };
//#else
__nes_code static inline void K6502_WriteW( WORD wAddr, WORD wData )
{
//	ROM[wAddr & PC_MASK] 		= wData & 0xff;
//	ROM[(wAddr + 1) & PC_MASK] 	= wData >>8; 
	ROMBANK[(wAddr>>13)&0x3][(wAddr)&0x1fff] 		= wData & 0xff;
	ROMBANK[((wAddr+1)>>13)&0x3][(wAddr+1)&0x1fff]	= wData >>8; 
};
//#endif
__nes_code static inline WORD K6502_ReadZpW( BYTE byAddr ){ return K6502_ReadZp( byAddr ) | ( K6502_ReadZp( byAddr + 1 ) << 8 ); };
//#define K6502_ReadZpW(byAddr)  (((DWORD)(RAM[ (BYTE)byAddr]) | ( (RAM[ (BYTE)(byAddr+1)]) << 8 )))
// 6502's indirect absolute jmp(opcode: 6C) has a bug (added at 01/08/15 )
//#if FAST_FUNC == 0
//static inline WORD K6502_ReadW2( WORD wAddr )
//{ 
//	//debg("[%x]",wAddr);
//  if ( 0x00ff == ( wAddr & 0x00ff ) )
//  {
//   return K6502_Read( wAddr ) | (WORD)K6502_Read( wAddr - 0x00ff ) << 8;
//   //return (WORD)RAM[ wAddr & 0x7ff ]| (RAM[ (wAddr -0x00ff) & 0x7ff ]<<8);
//  } else {
//    return K6502_Read( wAddr ) | (WORD)K6502_Read( wAddr + 1 ) << 8;
//	//return (WORD)RAM[ wAddr & 0x7ff ]| (RAM[ (wAddr +1) & 0x7ff ]<<8);
//  }
//}
//#endif
#endif /* !K6502_RW_H_INCLUDED */
