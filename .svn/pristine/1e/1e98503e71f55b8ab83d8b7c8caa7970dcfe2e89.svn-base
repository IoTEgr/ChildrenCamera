/****************************************************************************
**
 **                              MULTIMEDIA
  ** *   **             THE APPOTECH MULTIMEDIA PROCESSOR
   **** **                  MULTIMEDIA IMAGE ENCODE
  *** ***
 **  * **               (C) COPYRIGHT 2016 BUILDWIN 
**      **                         
         **         BuildWin SZ LTD.CO  ; VIDEO PROJECT TEAM
          **   
* File Name   : image_encode.c
* Author      : Mark.Douglas 
* Version     : V100
* Date        : 09/22/2016
* Description : This file is image encode file
*               
* History     : 
* 2016-09-22  : 
*      <1>.This is created by mark,set version as v100.
*      <2>.Add basic functions & information
******************************************************************************/
#include "../../media.h"
#include "../../multimedia.h"
#include "../../../hal/inc/hal_mjpeg.h"
#include "../../../ax32_platform_demo/application.h"

#if MEDIA_CFG_IMAGE_ENCODE_EN >0

#define  MJPEG_TYPE_VIDEO      0
#define  MJPEG_TYPE_PHOTO      1
#define  MJPEG_TYPE_UVC        2

#define  MANAGER_NAME_LEN     19

static INT32U jpegHeaderSize;
static const INT8U jpegEoi = 0xd9;
static INT8U jpegRst;
#define _JPG_SIZE_MIN_DEF2_		(50*1024)

//#define SDRAM_SIZE SDRAM_SIZE_2M


int hal_mjpegPhotoQuadCfgQuarter(u16 win_w, u16 win_h, u8 quality)
{
	mjpegEncCtrl.mjpeg_width = win_w;
	mjpegEncCtrl.mjpeg_height = win_h;
	quality = hal_mjpegQualityCheck(quality);
	
	//ax32xx_mjpeg_inlinebuf_init((u8*)mjpegEncCtrl.ybuffer,(u8*)mjpegEncCtrl.uvbuffer);
	ax32xx_mjpegEncodeSizeSet(HAL_CFG_MJPEG_WIDTH, HAL_CFG_MJPEG_HEIGHT, win_w, win_h);

	mjpegEncCtrl.curLen = mjpegEncCtrl.mjpsize;

	debg("PRE_JPCON1:%x,%x\n",quality,(PRE_JPCON1 >> 23)&0x0f);
	return 0;
}

#if 0//SDRAM_SIZE == SDRAM_SIZE_8M

static int jpegJfxxOffset;

static int myWrite(int fd, const void *buff, UINT len)
{
	const UINT WRITE_LEN = 256;
//	ax32xx_sysDcacheWback((u32)buff & ~0x3, (len + 0x3) & ~0x3);
	while (len > WRITE_LEN)
	{
		write(fd, buff, WRITE_LEN);
		buff += WRITE_LEN;
		len -= WRITE_LEN;
	}
	return write(fd, buff, len);
}

int hal_mjpegStitchQuadThumb(FHANDLE whole, u8 *upperLeft, u32 upperLeftSize, u8 *thumb, u32 thumbSize)
{
	int ret = 0;
	int i;
	u16 jfifLen, jfxxLen;
	u8 jfxx[] = {0xff, 0xe0, 0, 0, 'J', 'F', 'X', 'X', '\0', 0x10};
	for (i = 0; i < upperLeftSize; i++)
	{
		if (upperLeft[i] == 0xff && upperLeft[i + 1] == jfxx[1])
		{
			break;
		}
	}
	jfifLen = upperLeft[i + 2] << 8 | upperLeft[i + 3];
	jpegJfxxOffset = i + 2 + jfifLen;
	deg("StitchThumb:APP0 %d\n", jpegJfxxOffset);
	ret = write(whole, upperLeft, jpegJfxxOffset);
	if (ret < 0)
		return ret;
	for (i = 0; i < thumbSize; i++)
	{
		if (thumb[i] == 0xff && thumb[i + 1] == jfxx[1])
		{
			break;
		}
	}
	jfifLen = thumb[i + 2] << 8 | thumb[i + 3];
	jfxxLen = sizeof jfxx - 2 + thumbSize - 2 - jfifLen;
	jfxx[2] = jfxxLen >> 8;
	jfxx[3] = jfxxLen & 0xff;
	ax32xx_sysDcacheWback((u32)jfxx & ~0x3, sizeof jfxx);
	ret = write(whole, jfxx, sizeof jfxx);
	if (ret < 0)
		return ret;
	ret = write(whole, thumb, i);
	if (ret < 0)
		return ret;
	ret = myWrite(whole, thumb + i + 2 + jfifLen, thumbSize - i - 2 - jfifLen);
	if (ret < 0)
		return ret;
	return ret;
}

int hal_mjpegStitchQuadUpper(FHANDLE whole, u8 *upper[], u32 upperSize[])
{
	int ret = 0;
	INT8U marker[2];
	int offset[2];
	unsigned side;
	bool sos = false, eoi = false;

	offset[0] = jpegJfxxOffset;
	do
	{
		u8 *header;
		u16 headerLen;
		u16 width, height;
		header = upper[0] + offset[0];
		headerLen = header[2] << 8 | header[3];
		switch (header[1])
		{
		case 0xc0:
			height = header[5] << 8 | header[6];
			height *= 2;
			header[5] = height >> 8;
			header[6] = height & 0xff;
			width = header[7] << 8 | header[8];
			width *= 2;
			header[7] = width >> 8;
			header[8] = width & 0xff;
			break;
		case 0xda:
			sos = true;
			break;
		default:
			break;
		}
		offset[0] += 2 + headerLen;
	} while (!sos);
	deg("StitchUpper:SOS %d\n", offset[0]);
	ret = myWrite(whole, upper[0] + jpegJfxxOffset, offset[0] - jpegJfxxOffset);
	if (ret < 0)
		return ret;

	jpegHeaderSize = offset[0];

	offset[1] = jpegHeaderSize;
	side = 0;
	jpegRst = 0xd0;
	marker[0] = 0xd0;
	marker[1] = 0xd0;
	do
	{
		int i;
		for (i = offset[side]; i < upperSize[side] - 1; i++)
		{
			if (upper[side][i] == 0xff)
			{
				if (upper[side][i + 1] == marker[side])
				{
					marker[side]++;
					CLRB(marker[side], 3);
					upper[side][i + 1] = jpegRst;
					ax32xx_sysDcacheWback((u32)&upper[side][i + 1] & ~0x3, 8);
					jpegRst++;
					CLRB(jpegRst, 3);
					break;
				}
				else if (upper[side][i + 1] == jpegEoi)
				{
					if (side == 1)
						eoi = true;
					upper[side][i + 1] = jpegRst;
					ax32xx_sysDcacheWback((u32)&upper[side][i + 1] & ~0x3, 8);
					jpegRst++;
					CLRB(jpegRst, 3);
					break;
				}
			}
		}
		ret = myWrite(whole, upper[side] + offset[side], i + 2 - offset[side]);
		if (ret < 0)
			return ret;

		offset[side] = i + 2;
		side ^= 1;
	} while (!eoi);
	return ret;
}

int hal_mjpegStitchQuadLower(FHANDLE whole, u8 *lower[], u32 lowerSize[])
{
	int ret = 0;
	bool eoi = false;
	INT8U marker[2];
	int offset[2];
	unsigned side;

	offset[0] = jpegHeaderSize;
	offset[1] = jpegHeaderSize;

	side = 0;
	marker[0] = 0xd0;
	marker[1] = 0xd0;
	do
	{
		int i;
		for (i = offset[side]; i < lowerSize[side] - 1; i++)
		{
			if (lower[side][i] == 0xff)
			{
				if (lower[side][i + 1] == marker[side])
				{
					marker[side]++;
					CLRB(marker[side], 3);
					lower[side][i + 1] = jpegRst;
					ax32xx_sysDcacheWback((u32)&lower[side][i + 1] & ~0x3, 8);
					jpegRst++;
					CLRB(jpegRst, 3);
					break;
				}
				else if (lower[side][i + 1] == jpegEoi)
				{
					if (side == 0)
						lower[side][i + 1] = jpegRst;
					else
						eoi = true;
					break;
				}
			}
		}
		ret = myWrite(whole, lower[side] + offset[side], i + 2 - offset[side]);
		if (ret < 0)
			return ret;

		offset[side] = i + 2;
		side ^= 1;
	} while (!eoi);
	return ret;
}

#else

static struct
{
	INT8U *buf;
	int fd;
	UINT lenTotal;
	UINT lenUsed;
} wrCache;

static int w_test_open(int fd, UINT len)
{
	wrCache.fd = fd;
	wrCache.lenTotal = len;
	wrCache.lenUsed = 0;
	wrCache.buf = hal_sysMemMalloc(wrCache.lenTotal, 64);
	if (wrCache.buf)
		return 0;
	else
		return -9;
}

static void w_test_flush(void)
{
	UINT dataLen =0 ;
/*	const UINT WRITE_LEN = 512;
	while (wrCache.lenUsed > WRITE_LEN)
	{
		write(wrCache.fd, wrCache.buf + dataLen, WRITE_LEN);
		dataLen += WRITE_LEN;
		wrCache.lenUsed -= WRITE_LEN;
	}*/
	write(wrCache.fd, wrCache.buf + dataLen, wrCache.lenUsed);
	wrCache.lenUsed = 0;
}

static int w_test(int fd,const void *buff,UINT len)
{
	if (wrCache.buf == NULL)
		return -6;
	while (wrCache.lenUsed + len >= wrCache.lenTotal)
	{
		UINT lenPart = wrCache.lenTotal - wrCache.lenUsed;
		memcpy(wrCache.buf + wrCache.lenUsed, buff, lenPart);
		buff += lenPart;
		len -= lenPart;
		wrCache.lenUsed = wrCache.lenTotal;
		w_test_flush();
	}
	memcpy(wrCache.buf + wrCache.lenUsed, buff, len);
	wrCache.lenUsed += len;
	return 0;
}

static void w_test_close(void)
{
	if (wrCache.buf == NULL)
		return;
	w_test_flush();
	hal_sysMemFree(wrCache.buf);
	wrCache.buf = NULL;
}

int hal_mjpegStitchQuadThumb(FHANDLE whole, u8 *thumb, u32 thumbSize)
{
	int ret = 0;
	INT8U app[] = {0xff, 0xe9, 0, 10, 'J', 'R', 'X', '\0', 0, 0, 0, 0};
	INT32U thumbOffset;
	w_test_flush();
	thumbOffset = fs_tell(whole);
	ret = w_test(whole, thumb, thumbSize);
	if (ret < 0)
		return ret;
	deg("thumbOffset=0x%x\n", thumbOffset);
	app[8] = thumbOffset >> 24 & 0xff;
	app[9] = thumbOffset >> 16 & 0xff;
	app[10] = thumbOffset >> 8 & 0xff;
	app[11] = thumbOffset & 0xff;
	ret = w_test(whole, app, sizeof app);
	if (ret < 0)
		return ret;
	return ret;
}

int hal_mjpegStitchQuadUpper(FHANDLE whole, FHANDLE upper[])
{
	int ret = 0;
	//INT8U buf[2][1 << 9];
	ALIGNED(32) INT8U buf[2][1<<10];
	INT8U marker[2];
	int offset[2];
	unsigned side;
	INT16U width, height;
	INT32U fileOffset;
	lseek(upper[0], 0, 0);
	fileOffset = fs_tell(upper[0]);
	offset[0] = 0;
	ret = read(upper[0], buf[0], sizeof buf[0]);
	//ax32xx_sysDcacheWback(buf[0],sizeof buf[0]);
	if (ret < 0)
		return ret;
	marker[0] = 0xc0;
	do
	{
		bool found = false, foundMaybe = false;
		int i;
		for (i = 0; i < sizeof buf[0] - 1; i++)
		{
			if (buf[0][i] == 0xff && buf[0][i + 1] == marker[0])
			{
				found = true;
				break;
			}
		}
		ret = w_test(whole, buf[0], i + 1);
		if (ret < 0)
			return ret;
		offset[0] += i + 1;

		if (found)
			break;
		if (buf[0][i] == 0xff)
			foundMaybe = true;
		ret = read(upper[0], buf[0], sizeof buf[0]);
		if (ret < 0)
			return ret;
		if (foundMaybe && buf[0][0] == marker[0])
			break;
	} while (true);
	fileOffset += offset[0];
	offset[0] = offset[0] % sizeof buf[0];
	if (offset[0] + 7 >= sizeof buf[0])
	{
		lseek(upper[0], fileOffset, 0);
		ret = read(upper[0], buf[0], sizeof buf[0]);
		if (ret < 0)
			return ret;
		offset[0] = 0;
	}
	height = buf[0][offset[0] + 4] << 8 | buf[0][offset[0] + 5];
	height *= 2;
	buf[0][offset[0] + 4] = height >> 8;
	buf[0][offset[0] + 5] = height & 0xff;
	width = buf[0][offset[0] + 6] << 8 | buf[0][offset[0] + 7];
	width *= 2;
	buf[0][offset[0] + 6] = width >> 8;
	buf[0][offset[0] + 7] = width & 0xff;

	marker[0] = 0xda;
	do
	{
		bool found = false, foundMaybe = false;
		int i;
		for (i = offset[0]; i < sizeof buf[0] - 1; i++)
		{
			if (buf[0][i] == 0xff && buf[0][i + 1] == marker[0])
			{
				found = true;
				break;
			}
		}
		ret = w_test(whole, buf[0] + offset[0], i + 1 - offset[0]);
		if (ret < 0)
			return ret;
		fileOffset += i + 1 - offset[0];

		if (found)
		{
			offset[0] = i + 1;
			break;
		}
		if (buf[0][i] == 0xff)
			foundMaybe = true;
		ret = read(upper[0], buf[0], sizeof buf[0]);
		if (ret < 0)
			return ret;
		offset[0] = 0;
		if (foundMaybe && buf[0][0] == marker[0])
			break;
	} while (true);

	jpegHeaderSize = fileOffset + 13;
	lseek(upper[1], jpegHeaderSize, 0);
	ret = read(upper[1], buf[1], sizeof buf[1]);
	if (ret < 0)
		return ret;
	offset[1] = 0;

	side = 0;
	jpegRst = 0xd0;
	marker[0] = 0xd0;
	marker[1] = 0xd0;
	do
	{
		bool found = false, foundMaybe = false, foundRst = false;
		int i;
		for (i = offset[side]; i < sizeof buf[side] - 1; i++)
		{
			if (buf[side][i] == 0xff)
			{
				foundRst = buf[side][i + 1] == marker[side];
				if (foundRst || buf[side][i + 1] == jpegEoi)
				{
					found = true;
					break;
				}
			}
		}
		ret = w_test(whole, buf[side] + offset[side], i + 1 - offset[side]);
		if (ret < 0)
			return ret;

		if (found)
		{
			if (foundRst)
			{
				offset[side] = (i + 2) % sizeof buf[side];
				if (offset[side] == 0)
				{
					ret = read(upper[side], buf[side], sizeof buf[side]);
					if (ret < 0)
						return ret;
				}
				marker[side]++;
				CLRB(marker[side], 3);
			}
			ret = w_test(whole, &jpegRst, 1);
			if (ret < 0)
				return ret;
			jpegRst++;
			CLRB(jpegRst, 3);
			if (!foundRst && side == 1)
				break;
			side ^= 1;
			continue;
		}

		if (buf[side][i] == 0xff)
			foundMaybe = true;
		ret = read(upper[side], buf[side], sizeof buf[side]);
		if (ret < 0)
			return ret;
		offset[side] = 0;
		if (foundMaybe)
		{
			foundRst = buf[side][0] == marker[side];
			if (foundRst || buf[side][0] == jpegEoi)
			{
				if (foundRst)
				{
					offset[side]++;
					marker[side]++;
					CLRB(marker[side], 3);
				}
				ret = w_test(whole, &jpegRst, 1);
				if (ret < 0)
					return ret;
				jpegRst++;
				CLRB(jpegRst, 3);
				if (!foundRst && side == 1)
					break;
				side ^= 1;
				continue;
			}
		}
	} while (true);
	//deg("jpegRst=%x\n", jpegRst);
	return ret;
}

int hal_mjpegStitchQuadLower(FHANDLE whole, FHANDLE lower[])
{
	int ret = 0;
	ALIGNED(32) INT8U buf[2][1 << 10];//ALIGNED(32) INT8U buf[2][/*1 << 9*/1<<12];
	INT8U marker[2];
	int offset[2];
	unsigned side;

	lseek(lower[0], jpegHeaderSize, 0);
	ret = read(lower[0], buf[0], sizeof buf[0]);
	if (ret < 0)
		return ret;
	offset[0] = 0;

	lseek(lower[1], jpegHeaderSize, 0);
	ret = read(lower[1], buf[1], sizeof buf[1]);
	if (ret < 0)
		return ret;
	offset[1] = 0;

	side = 0;
	marker[0] = 0xd0;
	marker[1] = 0xd0;
	do
	{
		bool found = false, foundMaybe = false, foundRst = false;
		int i;
		for (i = offset[side]; i < sizeof buf[side] - 1; i++)
		{
			if (buf[side][i] == 0xff)
			{
				foundRst = buf[side][i + 1] == marker[side];
				if (foundRst || buf[side][i + 1] == jpegEoi)
				{
					found = true;
					break;
				}
			}
		}
		ret = w_test(whole, buf[side] + offset[side], i + 1 - offset[side]);
		if (ret < 0)
			return ret;

		if (found)
		{
			if (foundRst)
			{
				offset[side] = (i + 2) % sizeof buf[side];
				if (offset[side] == 0)
				{
					ret = read(lower[side], buf[side], sizeof buf[side]);
					if (ret < 0)
						return ret;
				}
				marker[side]++;
				CLRB(marker[side], 3);
			}
			if (!foundRst && side == 1)
			{
				ret = w_test(whole, &jpegEoi, 1);
				if (ret < 0)
					return ret;
				break;
			}
			ret = w_test(whole, &jpegRst, 1);
			if (ret < 0)
				return ret;
			jpegRst++;
			CLRB(jpegRst, 3);
			side ^= 1;
			continue;
		}

		if (buf[side][i] == 0xff)
			foundMaybe = true;
		ret = read(lower[side], buf[side], sizeof buf[side]);
		if (ret < 0)
			return ret;
		offset[side] = 0;
		if (foundMaybe)
		{
			foundRst = buf[side][0] == marker[side];
			if (foundRst || buf[side][0] == jpegEoi)
			{
				if (foundRst)
				{
					offset[side]++;
					marker[side]++;
					CLRB(marker[side], 3);
				}
				if (!foundRst && side == 1)
				{
					ret = w_test(whole, &jpegEoi, 1);
					if (ret < 0)
						return ret;
					break;
				}
				ret = w_test(whole, &jpegRst, 1);
				if (ret < 0)
					return ret;
				jpegRst++;
				CLRB(jpegRst, 3);
				side ^= 1;
				continue;
			}
		}
	} while (true);
	//deg("jpegRst=%x\n", jpegRst);
	return ret;
}
#endif

int hal_mjpegPhotoQuadStartThumbnail(u8 quality,u8 frame_enable,u8 timestamp)
{  
	u16 thumbWidth = mjpegEncCtrl.csi_width;
	u16 thumbHeight = mjpegEncCtrl.csi_height;

	hal_mjpegEncodeInit();
	hal_mjpeg_queue_init();
	hal_mjpeg_rev_buf_init();
	mjpegEncCtrl.line_buf_using = 0;
	mjpegEncCtrl.frame_enable = frame_enable;
	mjpegEncCtrl.type = MJPEG_TYPE_PHOTO;
	mjpegEncCtrl.mjpeg_width = thumbWidth;
	mjpegEncCtrl.mjpeg_height = thumbHeight;
	mjpegEncCtrl.csi_to_mjpeg_dma = 2;
	quality = JPEG_Q_27;
	ax32xx_mjpegEncodeInit(1,0);
	//uart_Printf("mjpegEncCtrl.csi_width=%d,mjpegEncCtrl.csi_height=%d\n",mjpegEncCtrl.csi_width,mjpegEncCtrl.csi_height);

//	ax32xx_csiScaler(mjpegEncCtrl.csi_width,mjpegEncCtrl.csi_height, mjpegEncCtrl.csi_width, mjpegEncCtrl.csi_height,
//		0,0, mjpegEncCtrl.csi_width, mjpegEncCtrl.csi_height);
//	ax32xx_csiMJPEGFrameSet(mjpegEncCtrl.ybuffer_limage, mjpegEncCtrl.uvbuffer_limage,
//		mjpegEncCtrl.csi_height, mjpegEncCtrl.csi_width);

	if(SysCtrl.crop_level)
	{
		u16 csi_w,csi_h,crop_w,crop_h;
		u16 sx,sy,ex,ey;
		u32 temp_uvbuf;
		
		hal_csiResolutionGet(&csi_w,&csi_h);
		crop_w =  ((csi_w * (100 - SysCtrl.crop_level*5/3) / 100) + 0x1f) & (~0x1f);
		crop_h = (csi_h * (100 - SysCtrl.crop_level*5/3) / 100) & ~1;
		sx = (csi_w - crop_w) / 2;
		ex = sx + crop_w;
		sy = (csi_h - crop_h) / 2;
		ey = sy + crop_h;
				
		//uart_Printf("crop_w=%d,crop_h=%d,sx=%d,ex=%d,sy=%d,ey=%d\n",crop_w,crop_h,sx,ex,sy,ey);
		temp_uvbuf= mjpegEncCtrl.ybuffer+crop_w*crop_h;
		ax32xx_mjpeg_inlinebuf_init((u8*)mjpegEncCtrl.ybuffer,(u8*)temp_uvbuf);
		ax32xx_csiScaler(mjpegEncCtrl.csi_width,mjpegEncCtrl.csi_height,crop_w,crop_h,sx,sy,ex,ey);
		ax32xx_mjpegEncodeSizeSet(crop_w,crop_h,mjpegEncCtrl.csi_width,mjpegEncCtrl.csi_height);
		ax32xx_csiMJPEGFrameSet(mjpegEncCtrl.ybuffer,temp_uvbuf,mjpegEncCtrl.csi_height,crop_w);
		
	}
	else{
	
		ax32xx_csiScaler(mjpegEncCtrl.csi_width,mjpegEncCtrl.csi_height, mjpegEncCtrl.csi_width, mjpegEncCtrl.csi_height,
			0,0, mjpegEncCtrl.csi_width, mjpegEncCtrl.csi_height);
		ax32xx_csiMJPEGFrameSet(mjpegEncCtrl.ybuffer, mjpegEncCtrl.uvbuffer,
			mjpegEncCtrl.csi_height, mjpegEncCtrl.csi_width);

		ax32xx_mjpegEncodeInit(1,0);
		ax32xx_mjpeg_inlinebuf_init((u8*)mjpegEncCtrl.ybuffer,(u8*)mjpegEncCtrl.uvbuffer);
		ax32xx_mjpegEncodeSizeSet(mjpegEncCtrl.csi_width, mjpegEncCtrl.csi_height, thumbWidth, thumbHeight);
	}
//	ax32xx_mjpeg_inlinebuf_init((u8*)mjpegEncCtrl.ybuffer_limage,(u8*)mjpegEncCtrl.uvbuffer_limage);
//	ax32xx_mjpegEncodeSizeSet(mjpegEncCtrl.csi_width, mjpegEncCtrl.csi_height, thumbWidth, thumbHeight);
	ax32xx_mjpegEncodeQuilitySet(quality);
	ax32xx_mjpegEncodeInfoSet(0);
	videoRecordImageWatermark(thumbWidth, thumbHeight, timestamp);
	//deg_Printf("the mjpbuf == %x\n",mjpegEncCtrl.mjpbuf);
	hal_streamInit(&mjpegEncCtrl.vids,mjpegEncCtrl.mjpegNode,MJPEG_ITEM_NUM,(u32)mjpegEncCtrl.mjpbuf,mjpegEncCtrl.mjpsize);
	//mjpegEncCtrl.curLen = mjpegEncCtrl.mjpsize;
	mjpegEncCtrl.curLen = _JPG_SIZE_MIN_DEF2_;
	SysCtrl.photo_finish_flag=1;
	mjpegEncCtrl.curBuffer = hal_streamMalloc(&mjpegEncCtrl.vids,mjpegEncCtrl.curLen);
	
	//deg_Printf("mbuff:%x,len == %x\n",mjpegEncCtrl.curBuffer,mjpegEncCtrl.curLen);
	if(mjpegEncCtrl.curBuffer==0)
		return;
	
	ax32xx_mjpegEncodeBufferSet(mjpegEncCtrl.curBuffer,mjpegEncCtrl.curBuffer+mjpegEncCtrl.curLen);	
	
	ax32xx_csiISRRegiser(CSI_IRQ_JPG_FRAME_END, hal_mjpeg_manual_quad_on);
	ax32xx_csiISRRegiser(CSI_IRQ_SEN_STATE_INT, NULL);
	ax32xx_csiISRRegiser(CSI_IRQ_VXY_FRAME_EN,NULL);
	ax32xx_mjpegEA_ncodeISRRegister(hal_mjpeg_manual_quad_fdown);

	ax32xx_csiOutputSet(CSI_OUTPUT_MJPGEN, 1);
	ax32xx_csiEnable(1);

	mjpegEncCtrl.drop = 0;
#if MJPEG_USE_BUF == MJPEG_DOUBLE_LINEBUF
	mjpegEncCtrl.line_buf_using = 1;
	mjpegEncCtrl.line_buf_deal = 1;
#else
	mjpegEncCtrl.line_buf_using = 0;
#endif
	return 0;
}

int hal_mjpegPhotoQuadStartQuarter(FHANDLE yuvfile,int lower, int right,u16 win_w, u16 win_h, u8 quality,u8 timestamp)
{
	int i;
	u8 *dstY = (u8 *)mjpegEncCtrl.ybuffer;
	u8 *dstUv = (u8 *)mjpegEncCtrl.uvbuffer;
	u8 *srcY; //= (u8 *)mjpegEncCtrl.ybuffer_limage;
	u8 *srcUv;// = (u8 *)mjpegEncCtrl.uvbuffer_limage;
	INT32S ret=0;
	
	hal_mjpeg_queue_init();
	hal_mjpeg_rev_buf_init();
	hal_mjpegRawBufferfree();
	
	ax32xx_mjpegEncodeInit(1,0);
	mjpegEncCtrl.mjpeg_width = win_w;
	mjpegEncCtrl.mjpeg_height = win_h;
	//quality = hal_mjpegQualityCheck(quality);
	
	//ax32xx_mjpeg_inlinebuf_init((u8*)mjpegEncCtrl.ybuffer,(u8*)mjpegEncCtrl.uvbuffer);
	ax32xx_mjpegEncodeSizeSet(HAL_CFG_MJPEG_WIDTH, HAL_CFG_MJPEG_HEIGHT, win_w, win_h);
	
	
	hal_streamInit(&mjpegEncCtrl.vids,mjpegEncCtrl.mjpegNode,MJPEG_ITEM_NUM,(u32)mjpegEncCtrl.mjpbuf,mjpegEncCtrl.mjpsize);
	
	mjpegEncCtrl.curLen       = _JPG_SIZE_MIN_DEF2_;
	SysCtrl.photo_finish_flag = 1;
	mjpegEncCtrl.curBuffer = hal_streamMalloc(&mjpegEncCtrl.vids,mjpegEncCtrl.curLen);
	//debg("mbuff:%x\n",mjpegEncCtrl.curBuffer);
	if(mjpegEncCtrl.curBuffer==0)
		return -1;
	
	if(!lower && !right){
		
		ax32xx_sysDcacheWback(mjpegEncCtrl.ybuffer, mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height/ 2);
		memcpy(mjpegEncCtrl.mjpbuf,mjpegEncCtrl.ybuffer,mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height/2);
	
		srcY = (u8 *)mjpegEncCtrl.mjpbuf;

		for (i = 0; i < HAL_CFG_MJPEG_HEIGHT; i++)
		{
			memcpy(dstY, srcY, HAL_CFG_MJPEG_WIDTH);
			dstY += HAL_CFG_MJPEG_WIDTH;
			srcY += mjpegEncCtrl.csi_width;
		}
		
		srcY = (u8 *)mjpegEncCtrl.mjpbuf+mjpegEncCtrl.csi_width/2;

		for (i = 0; i < HAL_CFG_MJPEG_HEIGHT; i++)
		{
			memcpy(dstY, srcY, HAL_CFG_MJPEG_WIDTH);
			dstY += HAL_CFG_MJPEG_WIDTH;
			srcY += mjpegEncCtrl.csi_width;
		}

		
		ax32xx_sysDcacheWback(mjpegEncCtrl.ybuffer+mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height/2, mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height/ 2);
		memcpy(mjpegEncCtrl.mjpbuf,mjpegEncCtrl.ybuffer+mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height/2,mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height/2);
	

		srcY = (u8 *)mjpegEncCtrl.mjpbuf;
		
		for (i = 0; i < HAL_CFG_MJPEG_HEIGHT; i++)
		{
			memcpy(dstY, srcY, HAL_CFG_MJPEG_WIDTH);
			dstY += HAL_CFG_MJPEG_WIDTH;
			srcY += mjpegEncCtrl.csi_width;
		}
		
		srcY = (u8 *)mjpegEncCtrl.mjpbuf+mjpegEncCtrl.csi_width/2;

		for (i = 0; i < HAL_CFG_MJPEG_HEIGHT; i++)
		{
			memcpy(dstY, srcY, HAL_CFG_MJPEG_WIDTH);
			dstY += HAL_CFG_MJPEG_WIDTH;
			srcY += mjpegEncCtrl.csi_width;
		}
		ax32xx_sysDcacheWback(mjpegEncCtrl.uvbuffer, mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height/ 2);
		memcpy(mjpegEncCtrl.mjpbuf,mjpegEncCtrl.uvbuffer,mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height/2);
	
		srcUv = (u8 *)mjpegEncCtrl.mjpbuf;
		
		for (i = 0; i < HAL_CFG_MJPEG_HEIGHT / 2; i++)
		{
			memcpy(dstUv, srcUv, HAL_CFG_MJPEG_WIDTH);
			dstUv += HAL_CFG_MJPEG_WIDTH;
			srcUv += mjpegEncCtrl.csi_width;
		}
		srcUv = (u8 *)mjpegEncCtrl.mjpbuf+mjpegEncCtrl.csi_width/2;

		for (i = 0; i < HAL_CFG_MJPEG_HEIGHT / 2; i++)
		{
			memcpy(dstUv, srcUv, HAL_CFG_MJPEG_WIDTH);
			dstUv += HAL_CFG_MJPEG_WIDTH;
			srcUv += mjpegEncCtrl.csi_width;
		}	

		srcUv = (u8 *)mjpegEncCtrl.mjpbuf+mjpegEncCtrl.csi_width*mjpegEncCtrl.csi_height / 4;
		
		for (i = 0; i < HAL_CFG_MJPEG_HEIGHT / 2; i++)
		{
			memcpy(dstUv, srcUv, HAL_CFG_MJPEG_WIDTH);
			dstUv += HAL_CFG_MJPEG_WIDTH;
			srcUv += mjpegEncCtrl.csi_width;
		}
		
		srcUv = (u8 *)mjpegEncCtrl.mjpbuf+mjpegEncCtrl.csi_width*mjpegEncCtrl.csi_height / 4+mjpegEncCtrl.csi_width/2;
		
		for (i = 0; i < HAL_CFG_MJPEG_HEIGHT / 2; i++)
		{
			memcpy(dstUv, srcUv, HAL_CFG_MJPEG_WIDTH);
			dstUv += HAL_CFG_MJPEG_WIDTH;
			srcUv += mjpegEncCtrl.csi_width;
		}	
		deg_Printf("write yuv file start\n");
		ret = write(yuvfile,(u8 *)mjpegEncCtrl.ybuffer,640*480*3/2);
		if(ret < 0){
			return -1;
		}
		deg_Printf("write yuv file ok\n");
	}
	
#if 0
	mjpegEncCtrl.ybuffer_limage = mjpegEncCtrl.ybuffer;
	mjpegEncCtrl.uvbuffer_limage = mjpegEncCtrl.uvbuffer;
		
	 if(right == 0 && lower == 1){
		mjpegEncCtrl.ybuffer_limage+=mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height / 2;
		mjpegEncCtrl.uvbuffer_limage += mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height / 4;	
		
	}else if(right == 1 && lower == 0){
	//`	mjpegEncCtrl.ybuffer_limage  +=mjpegEncCtrl.csi_width/2 * mjpegEncCtrl.csi_height / 2;
        mjpegEncCtrl.ybuffer_limage+=mjpegEncCtrl.csi_width* mjpegEncCtrl.csi_height / 4;
		mjpegEncCtrl.uvbuffer_limage += mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height / 8;
	}else if(right == 1 && lower == 1){
		mjpegEncCtrl.ybuffer_limage+=mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height*3 /4;
		mjpegEncCtrl.uvbuffer_limage += mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height*3 /8;
	}
	deg_Printf("StartQuarter the curBuff == %x,the curlen == %x......\n",mjpegEncCtrl.curBuffer,mjpegEncCtrl.curLen);
	videoRecordImageWatermark(mjpegEncCtrl.mjpeg_width, mjpegEncCtrl.mjpeg_height, timestamp);
	ax32xx_mjpeg_inlinebuf_init(mjpegEncCtrl.ybuffer_limage,mjpegEncCtrl.uvbuffer_limage);
	ax32xx_mjpegEncodeBufferSet(mjpegEncCtrl.curBuffer,mjpegEncCtrl.curBuffer+mjpegEncCtrl.curLen);	
#else
	mjpegEncCtrl.ybuffer_limage = mjpegEncCtrl.ybuffer;
	mjpegEncCtrl.uvbuffer_limage = mjpegEncCtrl.uvbuffer;
	u32 yoffset =0,uvoffset = 0;
	 if(right == 0 && lower == 1){
		yoffset=mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height / 2;
		uvoffset= mjpegEncCtrl.csi_height*mjpegEncCtrl.csi_width+mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height / 4;	
		
	}else if(right == 1 && lower == 0){
	//`	mjpegEncCtrl.ybuffer_limage  +=mjpegEncCtrl.csi_width/2 * mjpegEncCtrl.csi_height / 2;
        yoffset=mjpegEncCtrl.csi_width* mjpegEncCtrl.csi_height / 4;
		uvoffset= mjpegEncCtrl.csi_height*mjpegEncCtrl.csi_width+mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height / 8;
	}else if(right == 1 && lower == 1){
		yoffset=mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height*3 /4;
		uvoffset= mjpegEncCtrl.csi_height*mjpegEncCtrl.csi_width+mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height*3 /8;
	}
	if(!(!lower && !right)){
		lseek(yuvfile,yoffset,0);
		ret = read(yuvfile,mjpegEncCtrl.ybuffer,mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height / 4);
		if(ret < 0){
			return -1;
		}

		lseek(yuvfile,uvoffset,0);
		ret = read(yuvfile,mjpegEncCtrl.uvbuffer,mjpegEncCtrl.csi_width * mjpegEncCtrl.csi_height / 8);
		if(ret < 0){
			return -1;
		}
	}
	deg_Printf("StartQuarter the curBuff == %x,the curlen == %x......\n",mjpegEncCtrl.curBuffer,mjpegEncCtrl.curLen);
	videoRecordImageWatermark(mjpegEncCtrl.mjpeg_width, mjpegEncCtrl.mjpeg_height, timestamp);
	ax32xx_mjpeg_inlinebuf_init(mjpegEncCtrl.ybuffer,mjpegEncCtrl.uvbuffer);
	ax32xx_mjpegEncodeBufferSet(mjpegEncCtrl.curBuffer,mjpegEncCtrl.curBuffer+mjpegEncCtrl.curLen);	
#endif
	ax32xx_mjpeg_manual_on();
	ax32xx_intEnable(IRQ_JPGA,1); // enable jpegirq

	return 0;
}

int hal_imageWriteFile(FHANDLE fileHanle)
{
	INT32U timeout;
	INT8U err;
	INT32S res=0;
	JPEG_PHOTO_CACHE_T photo_cache;
	
	timeout = XOSTimeGet();
	 
	 while(1)
    {
		 photo_cache = *((JPEG_PHOTO_CACHE_T *)XMsgQPend(mjpegEncCtrl.photoCahQ,&err));
		 
		if((timeout+5000)<XOSTimeGet())
		{
			res = -3;
			deg_Printf("5s timeout : error\n");
			break;
		}
		if(SysCtrl.photo_finish_flag==2) //异常处理
		{
			res = -2;
			break;
		}
		
		if(err!=X_ERR_NONE) // no buffe
			continue;
		
		if(fileHanle){
			res =write(fileHanle,(void *)photo_cache.mem,(UINT)photo_cache.len);

			if(res<0)
			{
				deg_Printf("image encode : error\n");
				res = -1;
				break;
			}
		}
		if(photo_cache.flag){
			res = 0;
			deg_Printf("image ok \n");
			break;
		}
		deg_Printf("the mem == 0x%x,the len == %d\n",photo_cache.mem,photo_cache.len);

		if(photo_cache.mem  >= mjpegEncCtrl.mjpbuf && photo_cache.mem <= mjpegEncCtrl.mjpbuf+mjpegEncCtrl.mjpsize)
		{
			hal_mjpegRawDataSet(photo_cache.mem);
		}else{
			hal_mjpeg_rev_buf_free(photo_cache.mem);
		}
	}
	 
	ax32xx_wdtClear();
	return res;
}

int imageEncodeQuadStart(const char *path, FHANDLE fd, u16 width, u16 height, u8 quality, u8 timestamp,u8 frame_enable)
{
	int ret = 0;
#if 0//SDRAM_SIZE == SDRAM_SIZE_8M
	u8 *quarterBuf[2][2] = {{NULL,NULL},{NULL,NULL}};
#else
	int i, j;
	const char INFIX[2][2][3] = {{"UL", "UR"}, {"LL", "LR"}};
	const char TFIX[3] = {"TH"};
	const char YUVTEMP[3] = {"UV"};
	ptrdiff_t infixOffset;
	FHANDLE quarterFd[2][2];
	char quarterPath[2][2][32 + MANAGER_NAME_LEN + 1];
	char thnumPath[32 + MANAGER_NAME_LEN + 1];
	char YuvPath[32 + MANAGER_NAME_LEN + 1];
#endif
	void *quarterNode = NULL, *thumbNode = NULL;
	u32 quarterSize[2][2], thumbSize;
	s32 sync, sync_next;
	INT32U timeout;
	
	width = width /2;
	height = height/2;
	
	hal_mjpegEncodeResolutionImage(width,height);

	ret = w_test_open(fd, 1 << 13);
	if (ret < 0)
		goto ENCODE_END;
	ret = hal_mjpegMemInit(1);
	if (ret < 0)
	{
		deg("image encode: malloc fail\n");
		//return ret;
		goto ENCODE_END;
	}
	
	
#if 0//SDRAM_SIZE == SDRAM_SIZE_8M
#else
	infixOffset = strstr(path, "/PHO") + 2 - path;
	for (i = 0; i < ARRAY_NUM(quarterPath); i++)
	{
		for (j = 0; j < ARRAY_NUM(quarterPath[0]); j++)
		{
			strcpy(quarterPath[i][j], path);
			quarterPath[i][j][infixOffset] = INFIX[i][j][0];
			quarterPath[i][j][infixOffset + 1] = INFIX[i][j][1];
		}
	}
	strcpy(thnumPath, path);
	thnumPath[infixOffset] =   TFIX[0];
	thnumPath[infixOffset+1] = TFIX[1];

	strcpy(YuvPath, path);
	YuvPath[infixOffset] =   YUVTEMP[0];
	YuvPath[infixOffset+1] = YUVTEMP[1];
#endif
	FHANDLE thumbfile = open(thnumPath, FA_CREATE_NEW | FA_WRITE | FA_READ);
	if (thumbfile < 0)
	{
		deg("image encode: open thumbfile file fail\n");
		ret = -3;
		//return ret;
		goto ENCODE_END;
	}

//	videoRecordImageWatermark(width, height, timestamp);
	hal_mjpegPhotoQuadStartThumbnail(quality,frame_enable,timestamp);
#if 1
	//==wait csi yuv buf ok==
	timeout=XOSTimeGet();
	while(1)
	{
		if(hal_mjpeg_manual_get_csi_yuv_sta())
		{
			break;
		}
		
		if((timeout+1500)<XOSTimeGet())
		{
			ret = -2;
			goto ENCODE_END;
		}
	}
	//==end wait csi yuv buf ok==

	//==set lcd image stop==
	hal_wdtClear();
	hal_csiEnable(0);	
	dispLayerSetPIPMode(DISP_PIP_DISABLE);	


	if(SysCtrl.f_keysound)
	{
		logo_music_show(RES_MUSIC_TAKE_PHOTO);
	}
	while(audioPlaybackGetStatus() == MEDIA_STAT_PLAY);
	
	//==end set lcd image stop==

	//boardIoctrl(SysCtrl.bfd_led,IOCTRL_LED_NO0,1);

	//==software handle yuv buf ==
	hal_mjpeg_software_handle_csi_yuvbuf();
	//==end software handle yuv buf ==

	//==wait jpg encode==
	ax32xx_mjpeg_manual_on();
	ax32xx_intEnable(IRQ_JPGA,1); // enable jpegirq
#endif

	if(hal_imageWriteFile(thumbfile)<0){
		deg_Printf("write thumbfile failed\n");
		ret = -3;
		goto ENCODE_END;
	}	
	//close(thumbfile);
	
	if (timestamp)
		videoRecordImageWatermark(width, height, 0);
#if 1
//==decode jpg==
	if(0!=SysCtrl.crop_level)
	{
		INT32U len = fs_tell(thumbfile);
		lseek(thumbfile, 0, 0);
		ret = read(thumbfile, (void*)mjpegEncCtrl.mjpbuf, len);
		if(ret < 0)
		{
			deg("image encode: open upper file fail\n");
			ret = -3;
			//return ret;
			goto ENCODE_END;
		}
	
		ax32xx_csiEnable(1);
		dispLayerSetPIPMode(DISP_PIP_DISABLE);
		XOSTimeDly(20);
		u32 ticks=XOSTimeGet();
		Image_ARG_T arg;
		arg.target.width = mjpegEncCtrl.csi_width;
		arg.target.height = mjpegEncCtrl.csi_height;
		arg.yout  = (u8*)mjpegEncCtrl.ybuffer;
		arg.uvout = (u8*)mjpegEncCtrl.uvbuffer;
		arg.media.type = MEDIA_SRC_RAM;
		arg.media.src.buff = mjpegEncCtrl.mjpbuf;
		arg.wait = 1;  // wait decode end
		if(imageDecodeStart(&arg)<0)
		{
			deg("jpg decode fail\n");
		}
		else
		{
			ticks=XOSTimeGet()-ticks;
			//deg("jpg decode ok,ticks=%d\n",ticks);
			u16 dec_width,dec_height;
			imageDecodeGetResolution(&dec_width,&dec_height);
			//deg("jpg decode:w=%d,h=%d\n",dec_width,dec_height);
		}
		hal_csiEnable(1);
		dispLayerSetPIPMode(SysCtrl.pip_mode);
	}
#endif	
//==end decode jpg==
	close(thumbfile);
	hal_mjpegEncodeResolutionImageQuad(width, height);
	//ax32xx_mjpegEncodeInit(1,0);
	//hal_mjpegPhotoQuadCfgQuarter(width, height, quality);
	FHANDLE yuvfile = open(YuvPath, FA_CREATE_NEW | FA_WRITE | FA_READ);
	//deg("+-\n--\n");
	hal_mjpegPhotoQuadStartQuarter(yuvfile,0, 0,width, height, quality,0);

	quarterFd[0][0] = open(quarterPath[0][0], FA_CREATE_NEW | FA_WRITE | FA_READ);
	if (quarterFd[0][0] < 0)
	{
		deg("image encode: open upper file fail\n");
		ret = -3;
		//return ret;
		goto ENCODE_END;
	}
	if(hal_imageWriteFile(quarterFd[0][0])<0){
		deg_Printf("write file quarterFd[0][0] failed\n");
		ret = -3;
		goto ENCODE_END;
	}	

	
	//deg("++\n--\n");
	hal_mjpegPhotoQuadStartQuarter(yuvfile,0, 1,width, height, quality,0);

	quarterFd[0][1] = open(quarterPath[0][1], FA_CREATE_NEW | FA_WRITE | FA_READ);
	if (quarterFd[0][1] < 0)
	{
		deg("image encode: open upper file fail\n");
		ret = -3;
		//return ret;
		goto ENCODE_END;
	}
	
	if(hal_imageWriteFile(quarterFd[0][1])<0)
	{
		deg_Printf("write file quarterFd[0][1] failed\n");
		ret = -3;
		goto ENCODE_END;
	}	
	
	hal_mjpegStitchQuadUpper(fd, quarterFd[0]);
	close(quarterFd[0][0]);
	close(quarterFd[0][1]);

	//videoRecordImageWatermark(width, height, timestamp);
	//deg("++\n+-\n");
	hal_mjpegPhotoQuadStartQuarter(yuvfile,1, 0,width, height, quality,timestamp);

	quarterFd[1][0] = open(quarterPath[1][0], FA_CREATE_NEW | FA_WRITE | FA_READ);
	if (quarterFd[1][0] < 0)
	{
		deg("image encode: open lower file fail\n");
		ret = -3;
		//return ret;
		goto ENCODE_END;
	}

	if(hal_imageWriteFile(quarterFd[1][0])<0)
	{
		deg_Printf("write file quarterFd[1][0] failed\n");
		ret = -3;
		goto ENCODE_END;
	}	
	
	
	if (timestamp)
		videoRecordImageWatermark(width, height, 0);
	//deg("++\n++\n");
	hal_mjpegPhotoQuadStartQuarter(yuvfile,1, 1,width, height, quality,0);
	quarterFd[1][1] = open(quarterPath[1][1], FA_CREATE_NEW | FA_WRITE | FA_READ);
	if (quarterFd[1][1] < 0)
	{
		deg("image encode: open lower file fail\n");
		ret = -3;
		//return ret;
		goto ENCODE_END;
	}

	if(hal_imageWriteFile(quarterFd[1][1])<0){
		deg_Printf("write file quarterFd[1][1] failed\n");
		ret = -3;
		goto ENCODE_END;
	}

	hal_mjpegStitchQuadLower(fd, quarterFd[1]);
	close(yuvfile);
	thumbfile = open(thnumPath,  FA_WRITE | FA_READ);
	if (thumbfile < 0)
	{
		deg("image encode: open thumbfile file fail\n");
		ret = -3;
		goto ENCODE_END;
	}

	INT32U len = fs_size(thumbfile);
	//lseek(thumbfile, 0, 0);
	ret = read(thumbfile, (void*)mjpegEncCtrl.mjpbuf, len);
	if(ret < 0)
	{
		deg("image encode: open upper file fail\n");
		ret = -3;
		//return ret;
		goto ENCODE_END;
	}
	close(thumbfile);
	hal_mjpegStitchQuadThumb(fd, (u8*)mjpegEncCtrl.mjpbuf, len);


	ret = 0;
	U32 delaytime = XOSTimeGet();
	
ENCODE_END:

	//==lcd image active==
	if(XOSTimeGet()>200+delaytime)  //200ms
	{
		
	}
	else
	{
		if(delaytime+5<XOSTimeGet())
		{
			XOSTimeDly(200-(XOSTimeGet()-delaytime));
		}
		else
		{
			XOSTimeDly(200);
		}
	}
	hal_wdtClear();
	hal_csiEnable(1);
	dispLayerSetPIPMode(SysCtrl.pip_mode);
	hal_curBuffer_clear();

	w_test_close();		
	hal_mjpegRawBufferfree();
	hal_mjpegMemUninit();
	hal_mjpegEncodeStop();

	close(quarterFd[1][0]);
	close(quarterFd[1][1]);
	close(quarterFd[0][0]);
	close(quarterFd[0][1]);
	close(thumbfile);
	close(yuvfile);
	f_unlink(quarterPath[0][0]);
	f_unlink(quarterPath[0][1]);
	f_unlink(quarterPath[1][0]);
	f_unlink(quarterPath[1][1]);
	f_unlink(thnumPath);
	f_unlink(YuvPath);

	return ret;
}

#endif








